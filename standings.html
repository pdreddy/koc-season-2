<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings - KOC Season 2</title>
  <style>
    /* ===== Base / Theme (matches your site) ===== */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root{
      --bg1:#667eea; --bg2:#764ba2; --ink:#1a202c; --muted:#718096; --card:#ffffff;
      --ring:#e2e8f0; --accent:#22d3ee;
    }
    html,body{ height:100%; }
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      min-height:100vh; color:var(--ink);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Header & Nav ===== */
    .header{ position:sticky; top:0; z-index:50; backdrop-filter:blur(10px); }
    .header-bar{
      display:flex; align-items:center; justify-content:space-between;
      max-width:1100px; margin:0 auto; padding:.75rem 1rem;
      background:rgba(255,255,255,.95); box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    .brand{ display:flex; align-items:center; gap:.5rem; }
    .brand i{ font-size:1.5rem; }
    .brand strong{
      font-size:1.15rem; background:linear-gradient(135deg,var(--bg1),var(--bg2));
      -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
    }
    .menu-btn{ display:none; border:0; background:transparent; font-size:1.5rem; padding:.25rem .5rem; cursor:pointer; }
    nav.nav{
      max-width:1100px; margin:.35rem auto 0; display:flex; gap:.5rem; padding:.5rem 1rem;
      background:rgba(255,255,255,.9); border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    .nav a{
      text-decoration:none; color:#4a5568; font-weight:600;
      padding:.6rem 1rem; border-radius:8px; white-space:nowrap;
    }
    .nav a[aria-current="page"], .nav a:hover{
      color:#fff; background:linear-gradient(135deg,var(--bg1),var(--bg2));
    }

    /* ===== Layout ===== */
    .container{ max-width:1100px; margin:1rem auto 2rem; padding:0 1rem; }
    .page-header{
      background:#fff; border-radius:12px; padding:1.25rem 1.5rem; margin-bottom:1rem;
      box-shadow:0 2px 8px rgba(0,0,0,.08); border-left:4px solid var(--accent);
      text-align:center;
    }
    .page-header h1{ font-size:1.9rem; margin-bottom:.25rem; }
    .page-header p{ color:var(--muted); }

    .card{
      background:#fff; border-radius:12px; padding:1.25rem 1.5rem; margin-bottom:1rem;
      box-shadow:0 4px 12px rgba(0,0,0,.1);
    }
    .card h2{ margin-bottom:1rem; }

    /* ===== Access & Forms ===== */
    .access-card{ border:2px solid var(--accent); text-align:center; }
    .access-controls{ display:flex; gap:.6rem; justify-content:center; align-items:center; flex-wrap:wrap; }
    .access-input{
      padding:.7rem 1rem; border:2px solid var(--ring); border-radius:8px; min-width:240px;
    }
    .access-input:focus{ outline:none; border-color:var(--accent); }
    .btn{
      padding:.7rem 1.2rem; border:none; border-radius:8px; font-weight:800; color:#fff; cursor:pointer;
      background:linear-gradient(135deg,var(--bg1),var(--bg2)); box-shadow:0 2px 10px rgba(102,126,234,.35);
    }
    .btn.secondary{ background:#64748b; box-shadow:none; }
    .btn.success{ background:linear-gradient(135deg,#10b981,#059669); box-shadow:0 2px 10px rgba(16,185,129,.35); }
    .btn.warn{ background:linear-gradient(135deg,#f59e0b,#d97706); }
    .btn.danger{ background:linear-gradient(135deg,#ef4444,#dc2626); }
    .btn.ghost{ background:#fff; color:#1f2937; border:2px solid var(--ring); box-shadow:none; }

    .scoring-card{ border:2px solid var(--accent); background:linear-gradient(135deg,#f8fafc 0%,#f1f5f9 100%); }
    .card-header{ display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap; }
    .tools{ display:flex; gap:.5rem; flex-wrap:wrap; }

    .match-form{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:1rem; align-items:start; margin-top:.25rem;
    }
    .lineup-card{
      margin-top:1rem; background:#fff; border-radius:14px; border:2px solid rgba(34,211,238,.45);
      padding:1.1rem 1.25rem 1.25rem; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
      display:flex; flex-direction:column; gap:1rem;
    }
    .lineup-card h3{
      font-size:1.1rem; display:flex; align-items:center; gap:.5rem; color:#0f172a;
    }
    .lineup-card h3 span{ font-size:.9rem; color:#64748b; font-weight:500; }
    .lineup-grid{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:.9rem;
    }
    .lineup-block{
      background:linear-gradient(135deg,#f8fafc 0%,#f1f5f9 100%);
      border:1px dashed rgba(34,211,238,.5); border-radius:12px; padding:.9rem 1rem;
      display:flex; flex-direction:column; gap:.65rem; position:relative;
    }
    .lineup-block::before{
      content:""; position:absolute; inset:0; border-radius:12px; pointer-events:none;
      background:linear-gradient(135deg,rgba(34,211,238,.35),rgba(102,126,234,.35)); opacity:.6;
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor; mask-composite:exclude; padding:1px;
    }
    .lineup-title{
      font-weight:800; color:#0f172a; text-transform:uppercase; letter-spacing:.08em; font-size:.72rem;
    }
    .lineup-slot{ display:flex; flex-direction:column; gap:.35rem; }
    .lineup-slot label{ font-size:.75rem; text-transform:uppercase; letter-spacing:.08em; color:#475569; font-weight:700; }
    .lineup-card .player-select{ padding:.55rem .7rem; border:2px solid rgba(148,163,184,.45); border-radius:10px; font-weight:600; color:#0f172a; }
    .lineup-note{ font-size:.85rem; color:#475569; }
    .lineup-note strong{ color:#0f172a; }
    .team-input{
      display:flex; flex-direction:column; gap:.6rem; background:#fff; padding:1rem; border-radius:10px; border:2px solid var(--ring);
    }
    .input-label{ font-weight:800; text-align:center; }
    .select-input,.number-input,.text-input{
      padding:.7rem; border:2px solid var(--ring); border-radius:8px;
    }
    .select-input:focus,.number-input:focus,.text-input:focus{ outline:none; border-color:var(--accent); }
    .inline{ display:flex; gap:.5rem; align-items:center; justify-content:space-between; }

    .legend{ color:var(--muted); font-size:.9rem; margin-top:.5rem; text-align:center; }

    .line-editor{
      background:#fff; border-radius:16px; border:2px dashed rgba(34,211,238,.6); padding:1.25rem; display:flex; flex-direction:column; gap:1rem;
    }
    .line-header{ display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap; }
    .line-actions{ display:flex; gap:.5rem; flex-wrap:wrap; }
    .line-list{ display:flex; flex-direction:column; gap:.85rem; }
    .line-row{
      background:linear-gradient(135deg,#f8fafc 0%,#eef2ff 100%);
      border-radius:18px; padding:1rem 1.1rem; box-shadow:0 6px 18px rgba(15,23,42,.12);
      display:flex; flex-direction:column; gap:.9rem; position:relative;
    }
    .line-row::before{
      content:""; position:absolute; inset:0; border-radius:18px; padding:1px; pointer-events:none;
      background:linear-gradient(135deg,rgba(34,211,238,.8),rgba(102,126,234,.8)); -webkit-mask:
        linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
    }
    .line-row-header{ display:flex; align-items:center; justify-content:space-between; gap:.75rem; }
    .line-row .line-label{
      font-weight:700; border-radius:12px; border:2px solid rgba(148,163,184,.4); padding:.65rem 1rem; flex:1;
      background:#fff; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    }
    .line-row .line-label:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25);
      background:#f8feff;
    }
    .line-type-select{
      border:2px solid rgba(148,163,184,.4); border-radius:12px; padding:.55rem .9rem; font-weight:700; color:#0f172a;
      background:#fff; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    }
    .line-type-select:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25); }
    .line-remove{ border:0; background:#fee2e2; color:#ef4444; font-size:1.15rem; cursor:pointer; padding:.35rem .6rem; border-radius:10px; transition:.2s ease; }
    .line-remove:hover{ background:#fecaca; color:#b91c1c; }
    .line-scorecard{
      background:#fff; border-radius:14px; padding:1rem 1.1rem 1.1rem 1.45rem; display:flex; flex-direction:column; gap:.75rem; position:relative; overflow:hidden; --set-count:3;
    }
    .line-scorecard::before{
      content:""; position:absolute; left:0; top:0; bottom:0; width:4px; border-radius:14px 0 0 14px;
      background:linear-gradient(180deg,#22d3ee,#667eea);
    }
    .line-set-labels{
      display:grid; grid-template-columns:minmax(0,1.6fr) repeat(var(--set-count), minmax(60px,1fr)) minmax(60px,.9fr);
      padding-left:.75rem; font-size:.75rem; text-transform:uppercase; letter-spacing:.1em; color:#64748b; font-weight:700;
    }
    .line-set-labels span{ text-align:center; }
    .line-set-labels span:first-child{ opacity:.7; text-align:left; }
    .line-set-labels span[data-divider="true"]{ border-left:1px solid rgba(148,163,184,.4); padding-left:.5rem; }
    .line-match-tags{ display:flex; gap:.5rem; padding-left:.75rem; font-size:.7rem; font-weight:700; letter-spacing:.05em; color:#94a3b8; text-transform:uppercase; }
    .line-match-tags span{ background:rgba(148,163,184,.18); padding:.25rem .6rem; border-radius:999px; }
    .line-side{
      display:grid; grid-template-columns:minmax(0,1.7fr) repeat(var(--set-count), minmax(60px,1fr)) minmax(60px,.9fr);
      align-items:flex-start; justify-items:center; gap:.6rem; padding:.35rem .75rem;
    }
    .line-side > .line-side-info{ justify-self:start; }
    .line-side + .line-side{ border-top:1px solid rgba(148,163,184,.35); padding-top:.9rem; margin-top:.35rem; }
    .line-side-info{ display:flex; align-items:center; gap:.65rem; }
    .line-side-avatar{
      width:38px; height:38px; border-radius:50%; display:flex; align-items:center; justify-content:center;
      font-weight:800; background:linear-gradient(135deg,#667eea,#22d3ee); color:#fff; box-shadow:0 4px 10px rgba(79,70,229,.35);
    }
    .line-team-label{ font-weight:800; font-size:1rem; color:#1f2937; }
    .line-team-status{ font-size:.7rem; text-transform:uppercase; letter-spacing:.08em; color:#94a3b8; font-weight:800; margin-top:.15rem; }
    .line-team-status[data-state="incomplete"]{ color:#b45309; }
    .line-team-status[data-state="tied"]{ color:#b45309; }
    .line-team-status[data-state="winner"]{ color:#047857; }
    .player-picker{
      grid-column:1 / span 4; display:flex; flex-wrap:wrap; gap:.6rem; justify-content:flex-start; align-items:flex-start;
    }
    .player-field{ display:flex; flex-direction:column; gap:.25rem; min-width:140px; }
    .player-field.hidden{ display:none; }
    .player-slot-label{
      font-size:.7rem; text-transform:uppercase; letter-spacing:.08em; color:#64748b; font-weight:700;
    }
    .player-select{
      padding:.55rem .7rem; border:2px solid rgba(148,163,184,.4); border-radius:10px; background:#fff; font-weight:600;
      color:#0f172a;
    }
    .player-select:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25); }
    .line-player-summary{
      grid-column:1 / span 4; justify-self:stretch; background:rgba(148,163,184,.18); color:#475569;
      font-size:.8rem; padding:.35rem .6rem; border-radius:8px; display:flex; flex-wrap:wrap; gap:.75rem;
    }
    .line-player-summary strong{ font-weight:800; color:#1f2937; }
    .line-players{ margin-top:.35rem; font-size:.8rem; color:#475569; display:flex; flex-direction:column; gap:.2rem; }
    .line-players span{ display:block; }
    .history-line{ margin-bottom:.5rem; }
    .history-line:last-child{ margin-bottom:0; }
    .line-set-inputs{ display:grid; grid-template-columns:repeat(var(--set-count), minmax(60px,1fr)); gap:.45rem; grid-column:2 / span var(--set-count); }
    .set-field{ display:flex; flex-direction:column; align-items:center; gap:.35rem; }
    .set-field[data-divider="true"]{ border-left:1px solid rgba(148,163,184,.35); padding-left:.5rem; }
    .set-input{
      width:100%; padding:.55rem 0; border:2px solid rgba(148,163,184,.4); border-radius:10px; text-align:center; font-weight:800;
      font-size:1rem; background:#f8fafc; transition:.2s ease; color:#0f172a;
    }
    .set-input:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.2); background:#ecfeff; }
    .tie-break{ display:flex; align-items:center; gap:.35rem; font-size:.75rem; font-weight:700; color:#475569; }
    .tie-label{
      padding:.15rem .45rem; border-radius:999px; background:rgba(148,163,184,.2); letter-spacing:.05em;
    }
    .tie-input{
      width:3.25rem; padding:.35rem 0; border:2px solid rgba(148,163,184,.4); border-radius:8px; text-align:center; font-weight:700;
      font-size:.85rem; background:#fff; color:#0f172a;
    }
    .tie-input:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 2px rgba(34,211,238,.2); }
    .line-total{
      justify-self:center; font-weight:900; font-size:1.1rem; color:#1f2937; min-width:2.5rem; text-align:center; padding:.35rem .5rem;
      border-radius:10px; background:#f1f5f9;
    }
    .line-side.winner .line-team-status{ color:#047857; }
    .line-side.winner .line-total{ background:rgba(16,185,129,.15); color:#065f46; }
    .line-side.tied .line-team-status{ color:#b45309; }
    .line-side.tied .line-total{ background:rgba(251,191,36,.18); color:#92400e; }
    .line-hint{ color:var(--muted); font-size:.85rem; }
    .dreambreaker{ display:flex; flex-direction:column; gap:.5rem; }
    .dreambreaker-toggle{ display:flex; align-items:center; gap:.5rem; font-weight:600; }
    .dreambreaker-fields{ display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:.6rem; }
    .dreambreaker-fields .number-input{ width:100%; }
    .dreambreaker-note{ color:var(--muted); font-size:.85rem; }
    .history-table details{ color:var(--muted); }
    .history-table details summary{ cursor:pointer; color:#2563eb; font-weight:600; }
    .history-table details[open]{ padding-top:.35rem; }
    .history-table details[open] summary{ margin-bottom:.25rem; }

    .form-actions{ display:flex; gap:.6rem; justify-content:center; flex-wrap:wrap; margin-top:1rem; }
    .hidden{ display:none; }

    /* ===== Tables ===== */
    .table-container{ overflow-x:auto; }
    table{ width:100%; border-collapse:collapse; background:#fff; border-radius:8px; overflow:hidden; }
    thead th{
      background:linear-gradient(135deg,#0f172a,#1e293b); color:#fff; padding:.85rem; text-align:left;
    }
    tbody td{ padding:.85rem; border-bottom:1px solid var(--ring); }
    tbody tr:hover{ background:#f8fafc; }

    .standings-table tr.qualified{ background:linear-gradient(90deg,#d1fae5 0%, transparent 100%); }
    .standings-table tr.qualified:hover{ background:linear-gradient(90deg,#a7f3d0 0%, #f8fafc 100%); }

    .rank-cell{ font-weight:900; }
    .team-cell{ font-weight:800; }
    .center-cell{ text-align:center; }
    .points-cell{ font-weight:900; }

    .hint{ color:var(--muted); font-size:.9rem; margin-top:.35rem; }

    /* ===== Mobile ===== */
    @media (max-width:1024px){
      .card-header,
      .line-header{ flex-direction:column; align-items:flex-start; }
      .tools,
      .line-actions{ width:100%; justify-content:flex-start; }
    }

    @media (max-width:768px){
      .menu-btn{ display:block; }
      nav.nav{ display:none; flex-direction:column; }
      nav.nav.open{ display:flex; }
      .container{ padding:0 .75rem; }
      .match-form{ grid-template-columns:1fr; }
      .form-actions .btn,
      .access-controls .btn{ width:100%; }
      .card{ padding:1rem; }
      .access-controls{ flex-direction:column; align-items:stretch; }
      .access-input{ width:100%; min-width:0; }
      .tools .btn,
      .line-actions .btn{ width:100%; }
      .line-set-labels{ grid-template-columns:minmax(0,1fr) repeat(3, minmax(48px,1fr)) minmax(48px,.8fr); padding-left:.25rem; }
      .line-side{ grid-template-columns:minmax(0,1fr) repeat(3, minmax(48px,1fr)) minmax(48px,.8fr); padding:.5rem .5rem; }
      .line-set-inputs{ grid-template-columns:repeat(3, minmax(48px,1fr)); gap:.35rem; }
      .tie-input{ width:2.75rem; }
      .line-side-avatar{ width:34px; height:34px; font-size:.95rem; }
      .line-team-label{ font-size:.95rem; }
    }

    @media (max-width:640px){
      .page-header h1{ font-size:1.6rem; }
      .line-row{ padding:1rem; }
      .player-picker{ flex-direction:column; align-items:stretch; }
      .player-field{ min-width:0; width:100%; }
      .line-scorecard{ padding:1rem; }
      .line-set-labels{ display:none; }
      .line-side{ grid-template-columns:minmax(0,1fr); gap:.65rem; padding:.75rem .5rem; justify-items:stretch; }
      .line-side > .line-side-info{ flex-wrap:wrap; }
      .line-side-info{ align-items:flex-start; }
      .line-set-inputs{ grid-column:1; width:100%; }
      .tie-break{ grid-column:1; justify-content:flex-start; }
      .line-total{ grid-column:1; justify-self:flex-start; align-self:flex-start; display:inline-flex; }
      .line-side + .line-side{ margin-top:.65rem; padding-top:.65rem; }
      .dreambreaker-fields{ grid-template-columns:1fr; }
      .form-actions{ flex-direction:column; }
      .responsive-table thead{ display:none; }
      .responsive-table tbody{ display:block; }
      .responsive-table tbody tr{ display:block; border:1px solid var(--ring); border-radius:12px; margin-bottom:1rem; box-shadow:0 4px 12px rgba(15,23,42,.08); overflow:hidden; background:#fff; }
      .responsive-table tbody tr:last-child{ margin-bottom:0; }
      .responsive-table tbody td{ display:flex; flex-direction:column; align-items:flex-start; gap:.35rem; padding:.75rem 1rem; border-bottom:1px solid var(--ring); }
      .responsive-table tbody td:last-child{ border-bottom:none; }
      .responsive-table tbody td::before{ content:attr(data-label); font-weight:700; font-size:.75rem; text-transform:uppercase; letter-spacing:.08em; color:var(--muted); }
      .responsive-table tbody td.rank-cell,
      .responsive-table tbody td.points-cell{ align-items:flex-end; text-align:right; }
      .responsive-table tbody td.center-cell{ align-items:flex-start; text-align:left; }
      .table-container{ margin:0 -.5rem; padding:0 .5rem; }
    }
  </style>
</head>
<body>
<!-- Header -->
<header class="header">
  <div class="header-bar">
    <div class="brand" aria-label="KOC Season 2">
      <i>🏆</i><strong>KOC Season 2</strong>
    </div>
    <button id="menuBtn" class="menu-btn" aria-expanded="false" aria-controls="siteNav" aria-label="Toggle Menu">☰</button>
  </div>
  <nav id="siteNav" class="nav" aria-label="Primary">
    <!-- Order you asked for: Teams → Schedule → Rules → Standings -->
    <a href="index.html">👥 Teams</a>
    <a href="index22.html">📅 Schedule</a>
    <a href="rules.html">📋 Rules</a>
    <a href="standings.html" aria-current="page">📊 Standings</a>
  </nav>
</header>

<main class="container">
  <section class="page-header">
    <h1>Tournament Standings</h1>
    <p>Live rankings and match results (stored securely in Firebase)</p>
  </section>

  <!-- Access Code -->
  <section class="card access-card">
    <h2>🔒 Score Entry Access</h2>
    <div class="access-controls" style="margin:.5rem 0;">
      <input type="password" id="accessCode" placeholder="Enter access code" class="access-input" />
      <button class="btn" id="unlockBtn">Unlock Scoring</button>
    </div>
    <p class="hint">Captains: enter the secure access code provided by the organizers. Data is saved in <em>Firebase</em>.</p>
  </section>

  <!-- Scoring Form -->
  <section id="scoringForm" class="card scoring-card hidden">
    <div class="card-header">
      <h2>📝 Add Match Result (Best-of-5)</h2>
      <div class="tools">
        <button class="btn secondary" id="lockBtn">Lock</button>
        <button class="btn ghost" id="exportBtn">Export JSON</button>
        <label class="btn ghost" for="importFile" style="cursor:pointer;">Import JSON</label>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>
    </div>

    <div class="match-form">
      <div class="team-input">
        <label class="input-label">Team 1</label>
        <select id="team1Name" class="select-input" required>
          <option value="">Select Team 1</option>
        </select>
      </div>
      <div class="team-input">
        <label class="input-label">Team 2</label>
        <select id="team2Name" class="select-input" required>
          <option value="">Select Team 2</option>
        </select>
      </div>
    </div>

    <div class="lineup-card" id="lineupCard">
      <h3>👥 Lineups <span>Choose doubles pairs once per team, plus singles</span></h3>
      <div class="lineup-grid">
        <div class="lineup-block" data-team="1">
          <div class="lineup-title" aria-label="Team 1 lineup">Team 1</div>
          <div class="lineup-slot">
            <label for="team1Pair1Player1">Doubles Pair 1</label>
            <select id="team1Pair1Player1" class="player-select" data-team="1" data-slot="pair1" data-index="0"></select>
            <select id="team1Pair1Player2" class="player-select" data-team="1" data-slot="pair1" data-index="1"></select>
          </div>
          <div class="lineup-slot">
            <label for="team1Pair2Player1">Doubles Pair 2</label>
            <select id="team1Pair2Player1" class="player-select" data-team="1" data-slot="pair2" data-index="0"></select>
            <select id="team1Pair2Player2" class="player-select" data-team="1" data-slot="pair2" data-index="1"></select>
          </div>
          <div class="lineup-slot">
            <label for="team1Singles">Singles</label>
            <select id="team1Singles" class="player-select" data-team="1" data-slot="singles" data-index="0"></select>
          </div>
        </div>
        <div class="lineup-block" data-team="2">
          <div class="lineup-title" aria-label="Team 2 lineup">Team 2</div>
          <div class="lineup-slot">
            <label for="team2Pair1Player1">Doubles Pair 1</label>
            <select id="team2Pair1Player1" class="player-select" data-team="2" data-slot="pair1" data-index="0"></select>
            <select id="team2Pair1Player2" class="player-select" data-team="2" data-slot="pair1" data-index="1"></select>
          </div>
          <div class="lineup-slot">
            <label for="team2Pair2Player1">Doubles Pair 2</label>
            <select id="team2Pair2Player1" class="player-select" data-team="2" data-slot="pair2" data-index="0"></select>
            <select id="team2Pair2Player2" class="player-select" data-team="2" data-slot="pair2" data-index="1"></select>
          </div>
          <div class="lineup-slot">
            <label for="team2Singles">Singles</label>
            <select id="team2Singles" class="player-select" data-team="2" data-slot="singles" data-index="0"></select>
          </div>
        </div>
      </div>
      <p class="lineup-note">Each doubles pair will automatically play <strong>two</strong> matches across the four courts below: Round 1 versus the matching pair and Round 2 versus the opposite pair. Singles is a <strong>five-set</strong> match.</p>
    </div>

    <div class="line-editor" aria-labelledby="courtLabel">
      <div class="line-header">
        <div id="courtLabel"><strong>Court Breakdown</strong> (enter games won per court)</div>
        <div class="line-actions">
          <button type="button" class="btn ghost" id="resetLinesBtn">Reset Courts</button>
        </div>
      </div>
      <div id="lineContainer" class="line-list" aria-live="polite"></div>
      <p class="line-hint">After choosing your lineups above, enter set-by-set games for each court. If a set ends level, tiebreak boxes will appear so you can record the breaker.</p>
    </div>

    <div class="dreambreaker">
      <label class="dreambreaker-toggle"><input type="checkbox" id="dreambreakerToggle" /> Dreambreaker played</label>
      <div id="dreambreakerFields" class="dreambreaker-fields hidden">
        <div>
          <label>Dreambreaker Points (Team 1)</label>
          <input type="number" id="dreambreakerTeam1" class="number-input" min="0" max="20" step="1" />
        </div>
        <div>
          <label>Dreambreaker Points (Team 2)</label>
          <input type="number" id="dreambreakerTeam2" class="number-input" min="0" max="20" step="1" />
        </div>
      </div>
      <p class="dreambreaker-note">Use the dreambreaker fields only if total games are tied. Winner still earns <strong>1 match point</strong>.</p>
    </div>

    <p class="legend">Universal Tennis Team format: total match winner is determined by <strong>games won across all courts</strong>. Lineups, set totals, and dreambreaker results are saved so standings can track match points, set differential, and game differential automatically.</p>

    <div class="form-actions">
      <button class="btn success" id="addBtn">Save Result</button>
      <button class="btn warn" id="undoBtn" title="Remove the most recent match">Undo Last</button>
      <button class="btn danger" id="clearBtn" title="Clear ALL results">Clear All</button>
    </div>
  </section>

  <!-- Standings -->
  <section class="card standings-card">
    <h2>📊 Current Standings</h2>
    <div class="table-container">
      <table class="standings-table responsive-table">
        <thead>
        <tr>
          <th>Rank</th>
          <th>Team</th>
          <th>Matches</th>
          <th>Match Wins</th>
          <th>Match Losses</th>
          <th>Sets Won</th>
          <th>Sets Lost</th>
          <th>Set Diff</th>
          <th>Games Won</th>
          <th>Games Lost</th>
          <th>Game Diff</th>
          <th>Match Points</th>
        </tr>
        </thead>
        <tbody id="standingsBody">
        <tr><td colspan="12" class="center-cell" style="color:var(--muted);">No results yet. Add a match to see standings.</td></tr>
        </tbody>
      </table>
    </div>
    <p class="hint">Sorted by Match Points → Set Differential → Sets Won → Game Differential → Games Won (top 4 highlighted).</p>
  </section>

  <!-- Match History -->
  <section class="card history-card">
    <h2>📜 Match History</h2>
    <div class="table-container">
      <table class="history-table responsive-table">
        <thead>
        <tr>
          <th>#</th>
          <th>Teams</th>
          <th>Games (Sets)</th>
          <th>Winner</th>
          <th>Breakdown</th>
          <th>Date/Time</th>
        </tr>
        </thead>
        <tbody id="historyBody">
        <tr><td colspan="6" class="center-cell" style="color:var(--muted);">No matches recorded.</td></tr>
        </tbody>
      </table>
    </div>
  </section>
</main>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
  /* ==========
     Firebase Setup & Teams
     ========== */
  const firebaseConfig = {
    apiKey: "AIzaSyDbO0eP52i4t3V94bEiDcl7WoKbSrrM9VA",
    authDomain: "koc2-20fb8.firebaseapp.com",
    databaseURL: "https://koc2-20fb8-default-rtdb.firebaseio.com",
    projectId: "koc2-20fb8",
    storageBucket: "koc2-20fb8.firebasestorage.app",
    messagingSenderId: "317734341461",
    appId: "1:317734341461:web:1bcad5a1792fac0e46bddc"
  };

  const firebaseApp = firebase.apps && firebase.apps.length ? firebase.app() : firebase.initializeApp(firebaseConfig);
  const auth = firebaseApp.auth();
  const database = firebaseApp.database();
  const matchesRef = database.ref('season2Matches');

  let authReady = false;
  let authPromise = null;
  let authError = null;

  function ensureAuth(){
    if(authReady) return Promise.resolve();
    if(authPromise) return authPromise;
    authPromise = auth.signInAnonymously()
      .then(() => {
        authReady = true;
        authError = null;
      })
      .catch(err => {
        authReady = false;
        authError = err;
        throw err;
      })
      .finally(() => {
        authPromise = null;
      });
    return authPromise;
  }

  function getSelectedTeamMeta(team){
    const select = team === 1 ? t1 : t2;
    const value = select && select.value ? select.value.trim() : '';
    const data = value ? TEAM_LOOKUP.get(value) || null : null;
    const name = data ? data.name : (value || `Team ${team}`);
    let abbreviation = '';
    if(data && typeof data.abbreviation === 'string' && data.abbreviation.trim()){
      abbreviation = data.abbreviation.trim();
    }
    if(!abbreviation){
      abbreviation = value
        ? value.split(/\s+/).map(word => word.charAt(0).toUpperCase()).join('').slice(0,3) || value.charAt(0).toUpperCase()
        : `T${team}`;
    }
    const roster = data && Array.isArray(data.players) ? data.players.slice() : [];
    return { name, abbreviation, roster };
  }

  function getTeamDisplayName(team){
    return getSelectedTeamMeta(team).name;
  }

  function refreshLineTeamLabelsForRow(row){
    if(!row) return;
    const meta1 = getSelectedTeamMeta(1);
    const meta2 = getSelectedTeamMeta(2);
    row.querySelectorAll('.line-team-label').forEach(label => {
      const team = Number(label.dataset.team);
      if(team === 1){
        label.textContent = meta1.name;
      } else if(team === 2){
        label.textContent = meta2.name;
      }
    });
    row.querySelectorAll('.line-side-avatar').forEach(avatar => {
      const team = Number(avatar.dataset.team);
      const meta = team === 1 ? meta1 : meta2;
      avatar.textContent = meta.abbreviation || String(team);
      avatar.setAttribute('title', meta.name);
    });
    refreshLinePlayersForRow(row);
  }

  function refreshAllLineTeamLabels(){
    Array.from(lineContainer.querySelectorAll('.line-row')).forEach(refreshLineTeamLabelsForRow);
  }

  function uniquePairKeys(config, team){
    if(!config) return [];
    const seq = team === 1 ? config.team1Pairs : config.team2Pairs;
    if(!Array.isArray(seq)) return [];
    const order = [];
    seq.forEach(key => {
      if(key && !order.includes(key)) order.push(key);
    });
    return order;
  }

  function isLineupCompleteForRow(row, team){
    const config = getRoleConfig(row);
    if(!config){
      const players = getLinePlayers(row, team);
      return players.length > 0;
    }
    if(config.type === 'singles'){
      return Boolean(lineupState[team] && lineupState[team].singles);
    }
    const keys = uniquePairKeys(config, team);
    if(!keys.length) return false;
    return keys.every(key => {
      const pair = lineupState[team] && lineupState[team][key];
      return Array.isArray(pair) && pair.filter(Boolean).length === 2;
    });
  }

  function resetLineupForTeam(team){
    const config = lineupState[team];
    if(config){
      config.pair1 = [null, null];
      config.pair2 = [null, null];
      config.singles = null;
    }
    const selectors = lineupSelects[team];
    if(selectors){
      Object.values(selectors).forEach(list => {
        (Array.isArray(list) ? list : [list]).forEach(select => {
          if(select){
            select.value = '';
          }
        });
      });
    }
  }

  function enforceLineupUniqueness(team){
    const selectors = lineupSelects[team];
    if(!selectors) return;
    const all = [
      ...(selectors.pair1 || []),
      ...(selectors.pair2 || []),
      ...(selectors.singles || [])
    ].filter(Boolean);
    const taken = new Map();
    all.forEach(select => {
      const value = (select.value || '').trim();
      if(!value) return;
      if(!taken.has(value)) taken.set(value, new Set());
      taken.get(value).add(select);
    });
    const takenNames = new Set(taken.keys());
    all.forEach(select => {
      const current = (select.value || '').trim();
      Array.from(select.options).forEach(option => {
        if(option.value === ''){
          option.disabled = false;
          option.hidden = false;
          return;
        }
        if(option.value === current){
          option.disabled = false;
          option.hidden = false;
        } else if(takenNames.has(option.value)){
          option.disabled = true;
          option.hidden = true;
        } else {
          option.disabled = false;
          option.hidden = false;
        }
      });
    });
  }

  function lineupPlaceholder(slot, index){
    if(slot === 'singles') return 'Select singles player';
    return index === 0 ? 'Select player 1' : 'Select player 2';
  }

  function refreshLineupOptions(team){
    const selectors = lineupSelects[team];
    if(!selectors) return;
    const meta = getSelectedTeamMeta(team);
    const roster = Array.isArray(meta.roster) ? meta.roster : [];
    Object.entries(selectors).forEach(([slot, list]) => {
      const arr = Array.isArray(list) ? list : [list];
      arr.forEach((select, index) => {
        if(!select) return;
        const state = lineupState[team];
        const existing = slot === 'singles'
          ? (state && state.singles)
          : (state && Array.isArray(state[slot]) ? state[slot][index] : null);
        const previous = select.value || existing || '';
        select.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = roster.length ? lineupPlaceholder(slot, index) : 'Select team first';
        select.appendChild(placeholder);
        roster.forEach(player => {
          const opt = document.createElement('option');
          opt.value = player;
          opt.textContent = player;
          select.appendChild(opt);
        });
        if(previous && roster.includes(previous)){
          select.value = previous;
        } else {
          select.value = '';
        }
        if(slot === 'singles'){
          lineupState[team].singles = select.value ? select.value : null;
        } else {
          if(!Array.isArray(lineupState[team][slot])){
            lineupState[team][slot] = [null, null];
          }
          lineupState[team][slot][index] = select.value ? select.value : null;
        }
        select.disabled = roster.length === 0;
      });
    });
    enforceLineupUniqueness(team);
    updateAllLineupSummaries();
  }

  function updateAllLineupSummaries(){
    Array.from(lineContainer.querySelectorAll('.line-row')).forEach(row => {
      updateLineupSummary(row, 1);
      updateLineupSummary(row, 2);
    });
  }

  function handleTeamChange(team){
    resetLineupForTeam(team);
    refreshLineupOptions(team);
    refreshAllLineTeamLabels();
  }

  Object.entries(lineupSelects).forEach(([teamKey, slots]) => {
    const team = Number(teamKey);
    Object.entries(slots).forEach(([slot, list]) => {
      const arr = Array.isArray(list) ? list : [list];
      arr.forEach((select, index) => {
        if(!select) return;
        select.addEventListener('change', () => {
          const value = (select.value || '').trim() || null;
          if(slot === 'singles'){
            lineupState[team].singles = value;
          } else {
            if(!Array.isArray(lineupState[team][slot])){
              lineupState[team][slot] = [null, null];
            }
            lineupState[team][slot][index] = value;
          }
          enforceLineupUniqueness(team);
          updateAllLineupSummaries();
        });
      });
    });
  });

  function inferLineMode(label=''){
    const text = String(label || '').toLowerCase();
    if(text.includes('single')) return 'singles';
    return 'doubles';
  }

  function getRoleConfig(row){
    if(!row) return null;
    const role = row.dataset.matchRole;
    if(role && MATCH_ROLE_DETAILS[role]) return MATCH_ROLE_DETAILS[role];
    return null;
  }

  function getMatchPlayers(row, team, matchIdx){
    const config = getRoleConfig(row);
    if(config){
      if(config.type === 'singles'){
        const player = lineupState[team] && lineupState[team].singles ? lineupState[team].singles : null;
        return player ? [player] : [];
      }
      const pairList = team === 1 ? config.team1Pairs : config.team2Pairs;
      const key = Array.isArray(pairList) ? pairList[matchIdx] : null;
      if(!key || !lineupState[team]) return [];
      const pair = lineupState[team][key];
      return Array.isArray(pair) ? pair.filter(Boolean) : [];
    }
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"][data-match="${matchIdx}"]`));
    return selects.map(select => (select.value || '').trim()).filter(Boolean);
  }

  function getLinePlayers(row, team, { visibleOnly=true } = {}){
    if(!row) return [];
    const config = getRoleConfig(row);
    if(config){
      if(config.type === 'singles'){
        const player = lineupState[team] && lineupState[team].singles ? lineupState[team].singles : null;
        return player ? [player] : [];
      }
      const pairList = team === 1 ? config.team1Pairs : config.team2Pairs;
      if(Array.isArray(pairList)){
        const seen = new Set();
        const list = [];
        pairList.forEach(key => {
          if(!key || !lineupState[team]) return;
          const pair = lineupState[team][key];
          if(!Array.isArray(pair)) return;
          pair.forEach(player => {
            if(player && !seen.has(player)){
              seen.add(player);
              list.push(player);
            }
          });
        });
        return list;
      }
    }
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"]`));
    return selects
      .filter(select => {
        if(!visibleOnly) return true;
        const field = select.closest('.player-field');
        return !(field && field.classList.contains('hidden'));
      })
      .map(select => (select.value || '').trim())
      .filter(Boolean);
  }

  function enforceUniquePlayers(team){
    const container = document.getElementById('lineContainer');
    if(!container) return;
    const selects = Array.from(container.querySelectorAll(`.player-select[data-team="${team}"]`));
    const taken = new Map();
    selects.forEach(select => {
      const field = select.closest('.player-field');
      if(field && field.classList.contains('hidden')) return;
      const value = (select.value || '').trim();
      if(!value) return;
      if(!taken.has(value)) taken.set(value, new Set());
      taken.get(value).add(select);
    });
    const takenNames = new Set(taken.keys());
    selects.forEach(select => {
      const current = (select.value || '').trim();
      Array.from(select.options).forEach(option => {
        if(option.value === ''){
          option.disabled = false;
          option.hidden = false;
          return;
        }
        if(option.value === current){
          option.disabled = false;
          option.hidden = false;
        } else if(takenNames.has(option.value)){
          option.disabled = true;
          option.hidden = true;
        } else {
          option.disabled = false;
          option.hidden = false;
        }
      });
    });
  }

  function updateLineupSummary(row, team){
    if(!row) return;
    const summary = row.querySelector(`.line-player-summary[data-team="${team}"]`);
    if(!summary) return;
    const meta = getSelectedTeamMeta(team);
    const prefix = meta.abbreviation || meta.name;
    const config = getRoleConfig(row);
    let text = '—';
    if(config){
      if(config.type === 'singles'){
        const player = lineupState[team] && lineupState[team].singles ? lineupState[team].singles : null;
        text = player ? player : '—';
      } else {
        const keys = uniquePairKeys(config, team);
        if(keys.length){
          const parts = keys.map(key => {
            const players = lineupState[team] && Array.isArray(lineupState[team][key]) ? lineupState[team][key].filter(Boolean) : [];
            const label = key === 'pair1' ? 'Pair 1' : key === 'pair2' ? 'Pair 2' : key;
            return players.length ? `${label}: ${players.join(' / ')}` : `${label}: —`;
          });
          if(parts.length) text = parts.join(' • ');
        }
      }
    } else {
      const players = getLinePlayers(row, team);
      if(players.length) text = players.join(' / ');
    }
    summary.textContent = `${prefix} lineup: ${text}`;
    const status = row.querySelector(`.line-team-status[data-team="${team}"]`);
    if(status){
      const complete = isLineupCompleteForRow(row, team);
      status.dataset.defaultStatus = complete ? 'READY' : 'LINEUP';
      if(!status.dataset.state || status.dataset.state === 'default'){
        status.textContent = status.dataset.defaultStatus;
        status.dataset.state = 'default';
      }
    }
  }

  function refreshTeamPlayers(row, team){
    if(!row) return;
    const meta = getSelectedTeamMeta(team);
    const roster = Array.isArray(meta.roster) ? meta.roster : [];
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"]`));
    selects.forEach(select => {
      const slot = Number(select.dataset.slot);
      const previous = select.value || select.dataset.initialValue || '';
      delete select.dataset.initialValue;
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      if(!meta.name || roster.length === 0){
        placeholder.textContent = 'Select team first';
      } else if(mode === 'singles'){
        placeholder.textContent = 'Select player';
      } else {
        placeholder.textContent = `Select player ${slot + 1}`;
      }
      select.appendChild(placeholder);
      roster.forEach(player => {
        const opt = document.createElement('option');
        opt.value = player;
        opt.textContent = player;
        select.appendChild(opt);
      });
      if(previous && roster.includes(previous)){
        select.value = previous;
      } else {
        select.value = '';
      }
      select.disabled = roster.length === 0;
    });
    updateLineupSummary(row, team);
    enforceUniquePlayers(team);
  }

  function refreshLinePlayersForRow(row){
    refreshTeamPlayers(row, 1);
    refreshTeamPlayers(row, 2);
  }

  function applyPlayerSlotMode(row){
    if(!row) return;
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    row.querySelectorAll('.player-field').forEach(field => {
      const slot = Number(field.dataset.slot);
      const label = field.querySelector('.player-slot-label');
      const select = field.querySelector('.player-select');
      if(mode === 'singles'){
        if(slot === 0){
          field.classList.remove('hidden');
          if(label) label.textContent = 'Player';
        } else {
          field.classList.add('hidden');
          if(select) select.value = '';
        }
      } else {
        field.classList.remove('hidden');
        if(label) label.textContent = `Player ${slot + 1}`;
      }
    });
    updateLineupSummary(row, 1);
    updateLineupSummary(row, 2);
    enforceUniquePlayers(1);
    enforceUniquePlayers(2);
  }

  function updateLineTotals(row){
    if(!row) return;
    let partial = false;
    let seenAny = false;
    const setsForTotals = [];
    const lineMode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    const structure = getLineStructure(lineMode);
    const matchCount = structure.matches;
    const setsPerMatch = structure.sets;

    for(let matchIdx = 0; matchIdx < matchCount; matchIdx++){
      for(let setIdx = 0; setIdx < setsPerMatch; setIdx++){
        const t1Input = row.querySelector(`.set-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        const t2Input = row.querySelector(`.set-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        const tieWraps = row.querySelectorAll(`.tie-break[data-match="${matchIdx}"][data-set="${setIdx}"]`);
        const tieInputs = row.querySelectorAll(`.tie-input[data-match="${matchIdx}"][data-set="${setIdx}"]`);
        if(!t1Input || !t2Input){
          tieWraps.forEach(w => w.classList.add('hidden'));
          continue;
        }
        const raw1 = t1Input.value.trim();
        const raw2 = t2Input.value.trim();
        if(raw1 === '' && raw2 === ''){
          tieWraps.forEach(w => w.classList.add('hidden'));
          tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
          continue;
        }
        seenAny = true;
        if(raw1 === '' || raw2 === ''){
          partial = true;
          continue;
        }
        const val1 = Number(raw1);
        const val2 = Number(raw2);
        if(!Number.isInteger(val1) || !Number.isInteger(val2)){
          partial = true;
          continue;
        }
        if(val1 < 0 || val2 < 0 || val1 > MAX_SET_GAMES || val2 > MAX_SET_GAMES){
          partial = true;
          continue;
        }

        const isTieScore = val1 === val2;
        if(isTieScore){
          if(val1 !== TIE_TRIGGER_GAMES){
            partial = true;
            tieWraps.forEach(w => w.classList.add('hidden'));
            tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
            continue;
          }
        } else {
          const winnerScore = Math.max(val1, val2);
          const loserScore = Math.min(val1, val2);
          if(winnerScore !== MAX_SET_GAMES || loserScore > TIE_TRIGGER_GAMES){
            partial = true;
            tieWraps.forEach(w => w.classList.add('hidden'));
            tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
            continue;
          }
        }

        let tieBreak = null;
        if(val1 === val2){
          tieWraps.forEach(w => w.classList.remove('hidden'));
          const tieInput1 = row.querySelector(`.tie-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
          const tieInput2 = row.querySelector(`.tie-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
          const tieRaw1 = tieInput1 ? tieInput1.value.trim() : '';
          const tieRaw2 = tieInput2 ? tieInput2.value.trim() : '';
          if(tieRaw1 === '' && tieRaw2 === ''){
            partial = true;
            continue;
          }
          if(tieRaw1 === '' || tieRaw2 === ''){
            partial = true;
            continue;
          }
          const tie1 = Number(tieRaw1);
          const tie2 = Number(tieRaw2);
          if(!Number.isInteger(tie1) || !Number.isInteger(tie2) || tie1 === tie2 || tie1 < 0 || tie2 < 0 || tie1 > 30 || tie2 > 30){
            partial = true;
            continue;
          }
          tieBreak = { team1: tie1, team2: tie2 };
        } else {
          tieWraps.forEach(w => w.classList.add('hidden'));
          tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
        }

        setsForTotals.push({ team1: val1, team2: val2, tieBreak, match: matchIdx + 1, matchSet: setIdx + 1 });
      }
    }

    const totals = computeLineTotalsFromSets(setsForTotals);

    const sides = row.querySelectorAll('.line-side');
    sides.forEach(side => side.classList.remove('winner', 'tied'));

    let mode = 'empty';
    if(partial){
      mode = 'incomplete';
    } else if(setsForTotals.length){
      mode = 'complete';
    } else if(seenAny){
      mode = 'incomplete';
    }

    [1,2].forEach(team => {
      const totalEl = row.querySelector(`.line-total[data-team="${team}"]`);
      if(totalEl){
        if(mode === 'empty'){
          totalEl.textContent = '—';
        } else {
          const value = team === 1 ? totals.team1 : totals.team2;
          totalEl.textContent = value;
        }
      }
      const statusEl = row.querySelector(`.line-team-status[data-team="${team}"]`);
      if(!statusEl) return;
      if(mode === 'empty'){
        statusEl.textContent = statusEl.dataset.defaultStatus || '';
        statusEl.dataset.state = 'default';
      } else if(mode === 'incomplete'){
        statusEl.textContent = 'INCOMPLETE';
        statusEl.dataset.state = 'incomplete';
      } else {
        statusEl.textContent = 'TIED';
        statusEl.dataset.state = 'tied';
      }
    });

    if(mode === 'complete'){
      const status1 = row.querySelector('.line-team-status[data-team="1"]');
      const status2 = row.querySelector('.line-team-status[data-team="2"]');
      const side1 = row.querySelector('.line-side[data-team="1"]');
      const side2 = row.querySelector('.line-side[data-team="2"]');
      if(totals.team1 > totals.team2){
        if(status1){
          status1.textContent = 'WINNER';
          status1.dataset.state = 'winner';
        }
        if(status2){
          status2.textContent = status2.dataset.defaultStatus || '';
          status2.dataset.state = 'default';
        }
        if(side1) side1.classList.add('winner');
      } else if(totals.team2 > totals.team1){
        if(status2){
          status2.textContent = 'WINNER';
          status2.dataset.state = 'winner';
        }
        if(status1){
          status1.textContent = status1.dataset.defaultStatus || '';
          status1.dataset.state = 'default';
        }
        if(side2) side2.classList.add('winner');
      } else {
        if(status1){
          status1.textContent = 'TIED';
          status1.dataset.state = 'tied';
        }
        if(status2){
          status2.textContent = 'TIED';
          status2.dataset.state = 'tied';
        }
        if(side1) side1.classList.add('tied');
        if(side2) side2.classList.add('tied');
      }
    }
  }

  function formatLineSets(line, { html=false } = {}){
    if(!line) return '';
    if(Array.isArray(line.matches) && line.matches.length){
      const parts = line.matches.map((match, matchIdx) => {
        if(!match || !Array.isArray(match.sets) || !match.sets.length) return null;
        const label = typeof match.label === 'string' && match.label.trim() ? match.label.trim() : `Match ${match.match || (matchIdx + 1)}`;
        const setParts = match.sets.map((set, idx) => {
          const setNumber = Number(set.set);
          const labelText = Number.isInteger(setNumber) ? setNumber : (idx + 1);
          const t1 = Number(set.team1);
          const t2 = Number(set.team2);
          const safe1 = Number.isFinite(t1) ? t1 : set.team1;
          const safe2 = Number.isFinite(t2) ? t2 : set.team2;
          let text = `S${labelText} ${safe1}-${safe2}`;
          const tie = extractTieBreak(set);
          if(tie){
            text += ` (TB ${tie.team1}-${tie.team2})`;
          }
          return html ? escapeHTML(text) : text;
        });
        if(!setParts.length) return null;
        const block = `${label}: ${setParts.join(', ')}`;
        return html ? escapeHTML(block) : block;
      }).filter(Boolean);
      if(!parts.length) return '';
      return ` (${parts.join(html ? ' • ' : ' • ')})`;
    }
    if(!Array.isArray(line.sets) || !line.sets.length) return '';
    const parts = line.sets.map((set, idx) => {
      const setNumber = Number(set.set);
      const label = Number.isInteger(setNumber) ? setNumber : (idx + 1);
      const t1 = Number(set.team1);
      const t2 = Number(set.team2);
      const safe1 = Number.isFinite(t1) ? t1 : set.team1;
      const safe2 = Number.isFinite(t2) ? t2 : set.team2;
      let text = `S${label} ${safe1}-${safe2}`;
      const tie = extractTieBreak(set);
      if(tie){
        text += ` (TB ${tie.team1}-${tie.team2})`;
      }
      return html ? escapeHTML(text) : text;
    });
    return ` (${parts.join(', ')})`;
  }

  function formatLinePlayers(line, match){
    if(!line) return '';
    const team1Label = match && match.t1 ? match.t1 : 'Team 1';
    const team2Label = match && match.t2 ? match.t2 : 'Team 2';
    if(line.pairings && typeof line.pairings === 'object'){
      const team1Pairs = Array.isArray(line.pairings.team1) ? line.pairings.team1 : [];
      const team2Pairs = Array.isArray(line.pairings.team2) ? line.pairings.team2 : [];
      const length = Math.max(team1Pairs.length, team2Pairs.length);
      if(length){
        const rows = [];
        for(let i = 0; i < length; i++){
          const left = team1Pairs[i];
          const right = team2Pairs[i];
          const matchNumber = Number.isInteger(left && left.match) ? left.match : Number.isInteger(right && right.match) ? right.match : (i + 1);
          const leftNames = left && Array.isArray(left.players) && left.players.length ? left.players.join(' / ') : '—';
          const rightNames = right && Array.isArray(right.players) && right.players.length ? right.players.join(' / ') : '—';
          rows.push(`<span>Match ${matchNumber}: ${escapeHTML(team1Label)} ${escapeHTML(leftNames)} vs ${escapeHTML(team2Label)} ${escapeHTML(rightNames)}</span>`);
        }
        return `<div class="line-players">${rows.join('')}</div>`;
      }
    }
    if(!line.players) return '';
    const list1 = Array.isArray(line.players.team1) ? line.players.team1.filter(Boolean) : [];
    const list2 = Array.isArray(line.players.team2) ? line.players.team2.filter(Boolean) : [];
    if(!list1.length && !list2.length) return '';
    const left = list1.length ? list1.join(' / ') : '—';
    const right = list2.length ? list2.join(' / ') : '—';
    return `<div class="line-players"><span>${escapeHTML(team1Label)}: ${escapeHTML(left)}</span><span>${escapeHTML(team2Label)}: ${escapeHTML(right)}</span></div>`;
  }

  function formatLinePlayersText(line, match){
    if(!line) return '';
    const team1Label = match && match.t1 ? match.t1 : 'Team 1';
    const team2Label = match && match.t2 ? match.t2 : 'Team 2';
    if(line.pairings && typeof line.pairings === 'object'){
      const team1Pairs = Array.isArray(line.pairings.team1) ? line.pairings.team1 : [];
      const team2Pairs = Array.isArray(line.pairings.team2) ? line.pairings.team2 : [];
      const length = Math.max(team1Pairs.length, team2Pairs.length);
      if(length){
        const parts = [];
        for(let i = 0; i < length; i++){
          const left = team1Pairs[i];
          const right = team2Pairs[i];
          const matchNumber = Number.isInteger(left && left.match) ? left.match : Number.isInteger(right && right.match) ? right.match : (i + 1);
          const leftNames = left && Array.isArray(left.players) && left.players.length ? left.players.join(' / ') : '—';
          const rightNames = right && Array.isArray(right.players) && right.players.length ? right.players.join(' / ') : '—';
          parts.push(`Match ${matchNumber}: ${team1Label} ${leftNames} vs ${team2Label} ${rightNames}`);
        }
        return parts.join('; ');
      }
    }
    if(!line.players) return '';
    const list1 = Array.isArray(line.players.team1) ? line.players.team1.filter(Boolean) : [];
    const list2 = Array.isArray(line.players.team2) ? line.players.team2.filter(Boolean) : [];
    if(!list1.length && !list2.length) return '';
    const left = list1.length ? list1.join(' / ') : '—';
    const right = list2.length ? list2.join(' / ') : '—';
    return `${team1Label}: ${left} vs ${team2Label}: ${right}`;
  }

  ensureAuth().catch(err => {
    console.error('Failed to authenticate with Firebase', err);
    alert('⚠️ Unable to authenticate with Firebase. Scores will be read-only.');
  });

  async function guardWriteAccess(){
    try {
      await ensureAuth();
      if(!authReady){
        throw authError || new Error('Authentication is required.');
      }
      return true;
    } catch(err){
      console.error('Firebase authentication required before updating scores', err);
      alert('❌ Unable to authenticate with Firebase. Scores cannot be updated right now.');
      return false;
    }
  }

  const standingsBody = document.getElementById('standingsBody');
  const historyBody = document.getElementById('historyBody');
  standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">Loading standings from Firebase…</td></tr>';
  historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">Loading match history from Firebase…</td></tr>';

  let matches = [];
  let matchesLoaded = false;

  const TOURNAMENT = {
    tournament: 'Tournament Teams',
    description: '9 teams with 7 players each competing for the championship',
    teams: [
      {
        name: 'Rally Royals',
        abbreviation: 'RR',
        captain: 'Yogesh',
        players: [
          'Yogesh',
          'Srinivaasan Arumugam Sampath',
          'Charan Macharla',
          'Kalam Shaik',
          'Sandeep Gengineri',
          'Chandrakant Dharme',
          'Vasu Gandhi'
        ]
      },
      {
        name: "Karna's Crusaders",
        abbreviation: 'KC',
        captain: 'Srikanth',
        players: [
          'Srikanth',
          'Vibhor Sharma',
          'Malla Cheerke',
          'Anshul Goyal',
          'Srinidhi Kulkarni',
          'Lloyd Kumar',
          'Dinkar Bhardwaj'
        ]
      },
      {
        name: 'Spin Kings',
        abbreviation: 'SK',
        captain: 'Uma V',
        players: [
          'Uma V',
          'Madhu',
          'Noufal Mohamed',
          'Kanak Periasamy',
          'Fayaz',
          'KP Krishna',
          'Rajasekhar Mangalampally'
        ]
      },
      {
        name: 'KOC Challengers',
        abbreviation: 'KOCC',
        captain: 'Narayan Prasad',
        players: [
          'Narayan Prasad',
          'Nivas Nazeer',
          'Ravi Sengodan',
          'Damu Palavali',
          'Sarat Edara',
          'Vidya Sagar Reddy',
          'Sudhakar Nallapati'
        ]
      },
      {
        name: 'Rally Squad',
        abbreviation: 'RS',
        captain: 'Manish Jangid',
        players: [
          'Manish Jangid',
          'Srinivas Y',
          'Trinadh Cheepilla',
          'Biju Koshy',
          'Jitender Kumar',
          'Ritesh Kumar',
          'Dinesh Timmareddy'
        ]
      },
      {
        name: 'Agni Aces',
        abbreviation: 'AA',
        captain: 'Vinod Aripaka',
        players: [
          'Vinod Aripaka',
          'Gopi Guru',
          'Venu Servepalli',
          'Nazeer Mohammed',
          'Naveenkumar Mohanram',
          'Nizam Karimudeen',
          'Ratnesh Sinha'
        ]
      },
      {
        name: 'Chill Titans',
        abbreviation: 'CT',
        captain: 'Satish Orugunta',
        players: [
          'Satish Orugunta',
          'Gokul R',
          'Prashanth Tiramareddi',
          'Jaweed',
          'Ram Kantheti',
          'Durga',
          'Hari Mothukuri'
        ]
      },
      {
        name: 'Mega Lions',
        abbreviation: 'ML',
        captain: 'Anil Kunda',
        players: [
          'Anil Kunda',
          'Mirza H',
          'Raj Chejerla',
          'Mohan Koripuri',
          'Venky Dh',
          'Rajasekhar Karru',
          'Nagarjuna Saladi'
        ]
      },
      {
        name: 'Court Conquerors',
        abbreviation: 'CC',
        captain: 'Rajasekhar Chintha',
        players: [
          'Rajasekhar Chintha',
          'Venis V',
          'Jilani Pathan',
          'Bhaskar Boddireddy',
          'Ali Mohamed',
          'Sridhar K',
          'Krishna Vennapusa'
        ]
      }
    ]
  };

  const TEAM_LOOKUP = new Map(TOURNAMENT.teams.map(team => [team.name, team]));
  const TEAMS = TOURNAMENT.teams.map(team => team.name);
  const MATCH_ROLE_DETAILS = {
    'round1-court1': {
      label: 'Round 1 • Court 1',
      type: 'doubles',
      tags: ['Round 1', 'Pair 1 vs Pair 1'],
      team1Pairs: ['pair1'],
      team2Pairs: ['pair1']
    },
    'round1-court2': {
      label: 'Round 1 • Court 2',
      type: 'doubles',
      tags: ['Round 1', 'Pair 2 vs Pair 2'],
      team1Pairs: ['pair2'],
      team2Pairs: ['pair2']
    },
    'round2-court1': {
      label: 'Round 2 • Court 1',
      type: 'doubles',
      tags: ['Round 2', 'Pair 1 vs Pair 2'],
      team1Pairs: ['pair1'],
      team2Pairs: ['pair2']
    },
    'round2-court2': {
      label: 'Round 2 • Court 2',
      type: 'doubles',
      tags: ['Round 2', 'Pair 2 vs Pair 1'],
      team1Pairs: ['pair2'],
      team2Pairs: ['pair1']
    },
    'singles-main': {
      label: 'Singles • Line 1',
      type: 'singles',
      tags: ['Singles', '5 Sets']
    }
  };

  const DEFAULT_LINES = [
    { role: 'round1-court1' },
    { role: 'round1-court2' },
    { role: 'round2-court1' },
    { role: 'round2-court2' },
    { role: 'singles-main' }
  ];
  const MAX_SET_GAMES = 4;
  const TIE_TRIGGER_GAMES = Math.max(0, MAX_SET_GAMES - 1);
  const LINE_STRUCTURE = {
    doubles: { matches: 1, sets: 3 },
    singles: { matches: 1, sets: 5 }
  };

  function getLineStructure(mode){
    const key = mode === 'singles' ? 'singles' : 'doubles';
    return LINE_STRUCTURE[key];
  }

  const HTML_ESCAPE_LOOKUP = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' };
  const escapeHTML = (value='') => String(value).replace(/[&<>"']/g, ch => HTML_ESCAPE_LOOKUP[ch] || ch);

  function extractTieBreak(entry){
    if(!entry || typeof entry !== 'object') return null;
    const direct = entry.tieBreak ?? entry.tiebreak ?? entry.tb ?? null;
    let tie1;
    let tie2;
    if(direct && typeof direct === 'object'){
      tie1 = Number(direct.team1 ?? direct.t1 ?? direct.a ?? direct.score1 ?? direct.p1);
      tie2 = Number(direct.team2 ?? direct.t2 ?? direct.b ?? direct.score2 ?? direct.p2);
    }
    if(!Number.isInteger(tie1) || !Number.isInteger(tie2)){
      tie1 = Number(entry.tieBreakTeam1 ?? entry.tiebreakTeam1 ?? entry.tie1 ?? entry.tb1 ?? entry.t1tb ?? entry.tbTeam1);
      tie2 = Number(entry.tieBreakTeam2 ?? entry.tiebreakTeam2 ?? entry.tie2 ?? entry.tb2 ?? entry.t2tb ?? entry.tbTeam2);
    }
    if(!Number.isInteger(tie1) || !Number.isInteger(tie2)) return null;
    if(tie1 < 0 || tie2 < 0 || tie1 > 30 || tie2 > 30) return null;
    if(tie1 === tie2) return null;
    return { team1: tie1, team2: tie2 };
  }

  function computeLineTotalsFromSets(sets){
    if(!Array.isArray(sets) || !sets.length) return { team1:0, team2:0, sets1:0, sets2:0 };
    return sets.reduce((totals, set) => {
      const games1 = Number(set.team1);
      const games2 = Number(set.team2);
      if(Number.isInteger(games1)) totals.team1 += games1;
      if(Number.isInteger(games2)) totals.team2 += games2;
      if(Number.isInteger(games1) && Number.isInteger(games2)){
        if(games1 > games2){
          totals.sets1 += 1;
        } else if(games2 > games1){
          totals.sets2 += 1;
        } else {
          const tie = extractTieBreak(set) ?? (set.tieBreak ?? null);
          if(tie && Number.isInteger(tie.team1) && Number.isInteger(tie.team2) && tie.team1 !== tie.team2){
            if(tie.team1 > tie.team2){
              totals.team1 += 1;
              totals.sets1 += 1;
            } else {
              totals.team2 += 1;
              totals.sets2 += 1;
            }
          }
        }
      }
      return totals;
    }, { team1:0, team2:0, sets1:0, sets2:0 });
  }

  function sanitizeSetList(list){
    if(!Array.isArray(list)) return [];
    const clean = [];
    list.forEach((entry, idx) => {
      if(!entry) return;
      const t1 = Number(entry.team1 ?? entry.t1 ?? entry.a ?? entry.g1 ?? entry.score1);
      const t2 = Number(entry.team2 ?? entry.t2 ?? entry.b ?? entry.g2 ?? entry.score2);
      if(!Number.isInteger(t1) || !Number.isInteger(t2)) return;
      if(t1 < 0 || t2 < 0 || t1 > MAX_SET_GAMES || t2 > MAX_SET_GAMES) return;
      const isTie = t1 === t2;
      if(isTie){
        if(t1 !== TIE_TRIGGER_GAMES) return;
      } else {
        const winnerScore = Math.max(t1, t2);
        const loserScore = Math.min(t1, t2);
        if(winnerScore !== MAX_SET_GAMES) return;
        if(loserScore > TIE_TRIGGER_GAMES) return;
      }
      let setNumber = Number(entry.set ?? entry.index ?? entry.order ?? entry.num ?? (idx + 1));
      if(!Number.isInteger(setNumber) || setNumber < 1 || setNumber > 10){
        setNumber = clean.length + 1;
      }
      const tieBreak = t1 === t2 ? extractTieBreak(entry) : null;
      const payload = { set:setNumber, team1:t1, team2:t2 };
      if(tieBreak) payload.tieBreak = tieBreak;
      clean.push(payload);
    });
    clean.sort((a,b)=>a.set - b.set);
    return clean;
  }

  function sanitizePlayerList(value){
    if(!value) return [];
    let list = [];
    if(Array.isArray(value)){
      list = value;
    } else if(typeof value === 'string'){
      list = value.split(/[,/&]|\band\b/i);
    } else if(typeof value === 'object'){
      list = Object.values(value);
    }
    return list
      .map(entry => typeof entry === 'string' ? entry.trim() : '')
      .filter(Boolean)
      .slice(0, 2);
  }

  function sanitizeLineType(rawType, label='', team1Players=[], team2Players=[]){
    const normalized = typeof rawType === 'string' ? rawType.trim().toLowerCase() : '';
    if(normalized.startsWith('single')) return 'singles';
    if(normalized.startsWith('double')) return 'doubles';
    const maxPlayers = Math.max(team1Players.length, team2Players.length);
    if(maxPlayers <= 1 && maxPlayers > 0) return 'singles';
    const labelText = String(label || '').toLowerCase();
    if(labelText.includes('single')) return 'singles';
    if(labelText.includes('double')) return 'doubles';
    return 'doubles';
  }

  function sanitizeLines(list){
    if(!Array.isArray(list)) return [];
    const clean = [];
    list.forEach((entry) => {
      if(!entry) return;
      const label = typeof entry.label === 'string' ? entry.label.trim() : '';
      const matchListRaw = Array.isArray(entry.matches) ? entry.matches : [];
      const matchesPayload = matchListRaw.map((matchEntry, matchIdx) => {
        if(!matchEntry) return null;
        const matchLabel = typeof matchEntry.label === 'string' && matchEntry.label.trim() ? matchEntry.label.trim() : `Match ${matchIdx + 1}`;
        const sanitizedSets = sanitizeSetList(matchEntry.sets ?? matchEntry.setScores ?? matchEntry.list ?? matchEntry.data);
        return {
          match: Number(matchEntry.match ?? matchEntry.index ?? matchEntry.order ?? matchEntry.num ?? (matchIdx + 1)) || (matchIdx + 1),
          label: matchLabel,
          sets: sanitizedSets.map(set => {
            const payload = { set: set.set, team1: set.team1, team2: set.team2 };
            if(set.tieBreak){
              payload.tieBreak = { team1: set.tieBreak.team1, team2: set.tieBreak.team2 };
            }
            return payload;
          })
        };
      }).filter(Boolean);

      let sets = [];
      if(matchesPayload.length){
        matchesPayload.forEach((match, matchIdx) => {
          match.sets.forEach((set, setIdx) => {
            const payload = { set: sets.length + 1, team1: set.team1, team2: set.team2, match: match.match || (matchIdx + 1), matchSet: set.set || (setIdx + 1) };
            if(set.tieBreak){
              payload.tieBreak = { team1: set.tieBreak.team1, team2: set.tieBreak.team2 };
            }
            sets.push(payload);
          });
        });
      } else {
        sets = sanitizeSetList(entry.sets ?? entry.setScores ?? entry.setList);
      }

      let g1 = Number(entry.g1);
      let g2 = Number(entry.g2);
      let totals = null;
      if(sets.length){
        totals = computeLineTotalsFromSets(sets);
        g1 = totals.team1;
        g2 = totals.team2;
      }
      if(!Number.isInteger(g1) || !Number.isInteger(g2)) return;
      if(g1 < 0 || g2 < 0 || g1 > 90 || g2 > 90) return;
      const playersSource = (entry.players && typeof entry.players === 'object') ? entry.players : {};
      const team1Players = sanitizePlayerList(playersSource.team1 ?? entry.team1Players ?? entry.team1Lineup ?? entry.p1 ?? entry.lineup1);
      const team2Players = sanitizePlayerList(playersSource.team2 ?? entry.team2Players ?? entry.team2Lineup ?? entry.p2 ?? entry.lineup2);
      const lineType = sanitizeLineType(entry.type ?? entry.mode ?? entry.format, label, team1Players, team2Players);
      const cleanEntry = { label: label || `Court ${clean.length + 1}`, g1, g2, type: lineType };
      const rawRole = typeof entry.role === 'string' ? entry.role.trim() : '';
      if(rawRole) cleanEntry.role = rawRole;
      if(sets.length){
        cleanEntry.sets = sets.map(set => {
          const payload = { set:set.set, team1:set.team1, team2:set.team2 };
          if(typeof set.match !== 'undefined') payload.match = set.match;
          if(typeof set.matchSet !== 'undefined') payload.matchSet = set.matchSet;
          if(set.tieBreak) payload.tieBreak = { team1:set.tieBreak.team1, team2:set.tieBreak.team2 };
          return payload;
        });
      }
      if(matchesPayload.length){
        cleanEntry.matches = matchesPayload;
      }
      const totalsForSets = totals || { team1:g1, team2:g2, sets1:0, sets2:0 };
      let setWins = { team1: totalsForSets.sets1, team2: totalsForSets.sets2 };
      if(!sets.length){
        const rawSetWins1 = Number((entry.setWins && entry.setWins.team1) ?? entry.setWinsTeam1 ?? entry.s1 ?? entry.setsWonTeam1 ?? entry.sets1);
        const rawSetWins2 = Number((entry.setWins && entry.setWins.team2) ?? entry.setWinsTeam2 ?? entry.s2 ?? entry.setsWonTeam2 ?? entry.sets2);
        if(Number.isInteger(rawSetWins1) && Number.isInteger(rawSetWins2)){
          setWins = { team1: rawSetWins1, team2: rawSetWins2 };
        }
      }
      cleanEntry.setWins = setWins;
      if(team1Players.length || team2Players.length){
        cleanEntry.players = {};
        if(team1Players.length) cleanEntry.players.team1 = team1Players;
        if(team2Players.length) cleanEntry.players.team2 = team2Players;
      }
      const pairingsSource = entry.pairings && typeof entry.pairings === 'object' ? entry.pairings : null;
      if(pairingsSource){
        const cleanedPairings = {};
        ['team1','team2'].forEach(side => {
          const list = Array.isArray(pairingsSource[side]) ? pairingsSource[side] : [];
          const sanitized = list.map(item => {
            if(!item) return null;
            const matchValue = Number(item.match ?? item.matchIndex ?? item.index ?? item.num);
            const playersList = sanitizePlayerList(item.players ?? item.names ?? item.list);
            if(!playersList.length) return null;
            const payload = { players: playersList };
            if(Number.isInteger(matchValue) && matchValue > 0){
              payload.match = matchValue;
            }
            return payload;
          }).filter(Boolean);
          if(sanitized.length) cleanedPairings[side] = sanitized;
        });
        if((cleanedPairings.team1 && cleanedPairings.team1.length) || (cleanedPairings.team2 && cleanedPairings.team2.length)){
          cleanEntry.pairings = cleanedPairings;
        }
      }
      clean.push(cleanEntry);
    });
    return clean;
  }

  function sanitizeDreambreaker(db){
    if(!db) return null;
    const g1 = Number(db.g1 ?? db.team1 ?? db.t1 ?? db.points1 ?? db.p1);
    const g2 = Number(db.g2 ?? db.team2 ?? db.t2 ?? db.points2 ?? db.p2);
    if(!Number.isInteger(g1) || !Number.isInteger(g2)) return null;
    if(g1 < 0 || g2 < 0 || g1 > 40 || g2 > 40) return null;
    if(g1 === 0 && g2 === 0) return null;
    return { g1, g2 };
  }

  function deriveLineSetWins(line){
    if(!line) return { team1:0, team2:0 };
    const raw = line.setWins && typeof line.setWins === 'object' ? line.setWins : {};
    let team1 = Number(raw.team1 ?? raw.t1 ?? raw.a ?? raw.sets1 ?? raw.w1);
    let team2 = Number(raw.team2 ?? raw.t2 ?? raw.b ?? raw.sets2 ?? raw.w2);
    if(!Number.isInteger(team1) || !Number.isInteger(team2)){
      const totals = computeLineTotalsFromSets(line.sets || []);
      team1 = totals.sets1;
      team2 = totals.sets2;
    }
    team1 = Number.isInteger(team1) && team1 >= 0 ? team1 : 0;
    team2 = Number.isInteger(team2) && team2 >= 0 ? team2 : 0;
    return { team1, team2 };
  }

  function upgradeMatch(m){
    if(!m || !m.t1 || !m.t2) return null;
    const lines = sanitizeLines(m.lines);
    let g1 = Number(m.g1);
    let g2 = Number(m.g2);

    if(!Number.isFinite(g1) || !Number.isFinite(g2)){
      if(lines.length){
        g1 = lines.reduce((sum,row)=>sum + (Number(row.g1) || 0), 0);
        g2 = lines.reduce((sum,row)=>sum + (Number(row.g2) || 0), 0);
      } else if(typeof m.s1 !== 'undefined' && typeof m.s2 !== 'undefined'){
        const fallbackG1 = Number(m.s1);
        const fallbackG2 = Number(m.s2);
        if(Number.isFinite(fallbackG1) && Number.isFinite(fallbackG2) && (Math.abs(fallbackG1) > 6 || Math.abs(fallbackG2) > 6)){
          g1 = fallbackG1;
          g2 = fallbackG2;
        }
      }
    }

    if(!Number.isFinite(g1) || !Number.isFinite(g2)) return null;
    g1 = Math.round(g1);
    g2 = Math.round(g2);
    if(g1 < 0 || g2 < 0 || g1 > 120 || g2 > 120) return null;

    if(lines.length){
      const sum1 = lines.reduce((sum,row)=>sum + (Number(row.g1) || 0),0);
      const sum2 = lines.reduce((sum,row)=>sum + (Number(row.g2) || 0),0);
      g1 = sum1;
      g2 = sum2;
    }

    let sets1 = Number(m.s1);
    let sets2 = Number(m.s2);
    if(!Number.isInteger(sets1) || !Number.isInteger(sets2)){
      const setsObj = m.sets && typeof m.sets === 'object' ? m.sets : null;
      if(setsObj){
        const raw1 = Number(setsObj.team1 ?? setsObj.t1 ?? setsObj.a ?? setsObj.w1);
        const raw2 = Number(setsObj.team2 ?? setsObj.t2 ?? setsObj.b ?? setsObj.w2);
        if(Number.isInteger(raw1) && Number.isInteger(raw2)){
          sets1 = raw1;
          sets2 = raw2;
        }
      }
    }
    if(!Number.isInteger(sets1) || !Number.isInteger(sets2)){
      if(lines.length){
        const totalSets = lines.reduce((acc,line)=>{
          const wins = deriveLineSetWins(line);
          acc.team1 += wins.team1;
          acc.team2 += wins.team2;
          return acc;
        }, { team1:0, team2:0 });
        sets1 = totalSets.team1;
        sets2 = totalSets.team2;
      }
    }
    sets1 = Number.isInteger(sets1) && sets1 >= 0 ? sets1 : 0;
    sets2 = Number.isInteger(sets2) && sets2 >= 0 ? sets2 : 0;

    const dreambreaker = sanitizeDreambreaker(m.dreambreaker);
    const derivedWin = g1 === g2 ? null : (g1 > g2 ? m.t1 : m.t2);
    let win = (m.win === m.t1 || m.win === m.t2) ? m.win : derivedWin;
    if(!win && dreambreaker && dreambreaker.g1 !== dreambreaker.g2){
      win = dreambreaker.g1 > dreambreaker.g2 ? m.t1 : m.t2;
    }

    const tsNumber = Number(m.ts);
    const ts = Number.isFinite(tsNumber) ? tsNumber : Date.now();
    const upgraded = { t1:m.t1, t2:m.t2, g1, g2, win, ts, s1: sets1, s2: sets2 };
    if(lines.length) upgraded.lines = lines;
    if(dreambreaker && dreambreaker.g1 !== dreambreaker.g2) upgraded.dreambreaker = dreambreaker;
    return upgraded;
  }

  function handleSnapshot(snapshot){
    const data = snapshot.val();
    const list = [];
    if(data && typeof data === 'object'){
      for(const [id, entry] of Object.entries(data)){
        const upgraded = upgradeMatch(entry);
        if(upgraded){
          upgraded.id = id;
          list.push(upgraded);
        }
      }
    }
    matches = list.sort((a,b)=>b.ts - a.ts);
    matchesLoaded = true;
    renderAll();
  }

  async function handleMatchesError(error){
    console.error('Failed to load matches from Firebase', error);
    if(error && error.code === 'PERMISSION_DENIED'){
      try {
        await ensureAuth();
        if(authReady){
          subscribeToMatches();
          return;
        }
      } catch(authErr){
        console.error('Firebase authentication attempt failed while retrying listener', authErr);
      }
    }
    matches = [];
    matchesLoaded = true;
    renderAll();
    alert('❌ Failed to load matches from server. Please try again later.');
  }

  function subscribeToMatches(){
    matchesRef.off();
    matchesRef.on('value', handleSnapshot, handleMatchesError);
  }

  subscribeToMatches();

  /* ==========
     UI: Nav (mobile)
     ========== */
  const menuBtn = document.getElementById('menuBtn');
  const siteNav = document.getElementById('siteNav');
  menuBtn.addEventListener('click', () => {
    const open = siteNav.classList.toggle('open');
    menuBtn.setAttribute('aria-expanded', String(open));
  });

  /* ==========
     Access Lock/Unlock
     ========== */
  const scoringForm = document.getElementById('scoringForm');
  document.getElementById('unlockBtn').addEventListener('click', () => {
    const code = (document.getElementById('accessCode').value || '').trim();
    if(code === 'KOCPO#2'){
      scoringForm.classList.remove('hidden');
      document.getElementById('accessCode').value = '';
      alert('✅ Scoring unlocked');
    } else {
      alert('❌ Invalid code');
    }
  });
  document.getElementById('lockBtn').addEventListener('click', () => {
    scoringForm.classList.add('hidden');
    alert('🔒 Scoring locked');
  });

  /* ==========
     Populate selects
     ========== */
  const t1 = document.getElementById('team1Name');
  const t2 = document.getElementById('team2Name');
  function fillTeams(){
    const opts = ['<option value="">Select Team</option>', ...TEAMS.map(n=>`<option value="${n}">${n}</option>`)].join('');
    t1.innerHTML = opts.replace('Select Team','Select Team 1');
    t2.innerHTML = opts.replace('Select Team','Select Team 2');
  }
  fillTeams();
  t1.addEventListener('change', () => handleTeamChange(1));
  t2.addEventListener('change', () => handleTeamChange(2));

  /* ==========
     Court editor helpers
     ========== */
  const lineContainer = document.getElementById('lineContainer');
  const resetLinesBtn = document.getElementById('resetLinesBtn');
  const dreambreakerToggle = document.getElementById('dreambreakerToggle');
  const dreambreakerFields = document.getElementById('dreambreakerFields');
  const dreambreakerTeam1 = document.getElementById('dreambreakerTeam1');
  const dreambreakerTeam2 = document.getElementById('dreambreakerTeam2');
  const lineupSelects = {
    1: {
      pair1: [
        document.getElementById('team1Pair1Player1'),
        document.getElementById('team1Pair1Player2')
      ],
      pair2: [
        document.getElementById('team1Pair2Player1'),
        document.getElementById('team1Pair2Player2')
      ],
      singles: [document.getElementById('team1Singles')]
    },
    2: {
      pair1: [
        document.getElementById('team2Pair1Player1'),
        document.getElementById('team2Pair1Player2')
      ],
      pair2: [
        document.getElementById('team2Pair2Player1'),
        document.getElementById('team2Pair2Player2')
      ],
      singles: [document.getElementById('team2Singles')]
    }
  };
  const lineupState = {
    1: { pair1: [null, null], pair2: [null, null], singles: null },
    2: { pair1: [null, null], pair2: [null, null], singles: null }
  };

  function buildMatchPrefill(mode, matchesConfig=null, rawSets=[]){
    const structure = getLineStructure(mode);
    const matchCount = structure.matches;
    const setsPerMatch = structure.sets;
    const base = Array.from({ length: matchCount }, (_, idx) => ({
      label: `Match ${idx + 1}`,
      sets: Array.from({ length: setsPerMatch }, () => ({}))
    }));

    if(Array.isArray(matchesConfig)){
      matchesConfig.forEach((match, matchIdx) => {
        if(!match || matchIdx >= matchCount) return;
        if(typeof match.label === 'string' && match.label.trim()){
          base[matchIdx].label = match.label.trim();
        }
        const matchSets = Array.isArray(match.sets) ? match.sets : [];
        matchSets.forEach((set, setIdx) => {
          if(!set || setIdx >= setsPerMatch) return;
          const entry = {};
          const val1 = Number(set.team1 ?? set.t1 ?? set.a ?? set.g1 ?? set.score1);
          const val2 = Number(set.team2 ?? set.t2 ?? set.b ?? set.g2 ?? set.score2);
          if(Number.isInteger(val1)) entry.team1 = val1;
          if(Number.isInteger(val2)) entry.team2 = val2;
          const tieBreak = extractTieBreak(set);
          if(tieBreak) entry.tieBreak = tieBreak;
          base[matchIdx].sets[setIdx] = entry;
        });
      });
    }

    if(Array.isArray(rawSets)){
      rawSets.forEach((set, idx) => {
        if(!set) return;
        let matchIdx = Number(set.match ?? set.matchIndex ?? set.matchNumber ?? set.matchNum);
        if(Number.isInteger(matchIdx)){
          matchIdx = matchIdx - 1;
        } else {
          matchIdx = Math.floor(idx / setsPerMatch);
        }
        if(!Number.isInteger(matchIdx)) matchIdx = 0;
        matchIdx = Math.min(Math.max(matchIdx, 0), matchCount - 1);

        let setIdx = Number(set.matchSet ?? set.matchSetIndex ?? set.matchSetNumber ?? set.setWithinMatch ?? set.within ?? set.part);
        if(Number.isInteger(setIdx)){
          setIdx = setIdx - 1;
        } else {
          setIdx = idx % setsPerMatch;
        }
        if(!Number.isInteger(setIdx)) setIdx = 0;
        setIdx = Math.min(Math.max(setIdx, 0), setsPerMatch - 1);

        const entry = Object.assign({}, base[matchIdx].sets[setIdx]);
        const val1 = Number(set.team1 ?? set.t1 ?? set.a ?? set.g1 ?? set.score1);
        const val2 = Number(set.team2 ?? set.t2 ?? set.b ?? set.g2 ?? set.score2);
        if(Number.isInteger(val1)) entry.team1 = val1;
        if(Number.isInteger(val2)) entry.team2 = val2;
        const tieBreak = extractTieBreak(set);
        if(tieBreak) entry.tieBreak = tieBreak;
        base[matchIdx].sets[setIdx] = entry;
      });
    }

    return base;
  }

  function captureLineInputValues(row, modeOverride){
    if(!row) return null;
    const mode = modeOverride || (row.dataset.mode === 'singles' ? 'singles' : 'doubles');
    const structure = getLineStructure(mode);
    const matchCount = structure.matches;
    const setsPerMatch = structure.sets;
    return Array.from({ length: matchCount }, (_, matchIdx) => ({
      label: `Match ${matchIdx + 1}`,
      sets: Array.from({ length: setsPerMatch }, (_, setIdx) => {
        const payload = {};
        const input1 = row.querySelector(`.set-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        const input2 = row.querySelector(`.set-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        if(input1 && input1.value !== '' && Number.isInteger(Number(input1.value))){
          payload.team1 = Number(input1.value);
        }
        if(input2 && input2.value !== '' && Number.isInteger(Number(input2.value))){
          payload.team2 = Number(input2.value);
        }
        const tie1 = row.querySelector(`.tie-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        const tie2 = row.querySelector(`.tie-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
        if(tie1 && tie2 && tie1.value !== '' && tie2.value !== '' && Number.isInteger(Number(tie1.value)) && Number.isInteger(Number(tie2.value))){
          payload.tieBreak = { team1: Number(tie1.value), team2: Number(tie2.value) };
        }
        return payload;
      })
    }));
  }

  function renderLineSetStructure(row, matchesPrefill=null){
    if(!row) return;
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    const structure = getLineStructure(mode);
    const matchCount = structure.matches;
    const setsPerMatch = structure.sets;
    const scorecard = row.querySelector('.line-scorecard');
    if(scorecard){
      scorecard.style.setProperty('--set-count', String(matchCount * setsPerMatch));
    }
    const matchData = Array.isArray(matchesPrefill) ? matchesPrefill : buildMatchPrefill(mode);
    const setLabels = row.querySelector('.line-set-labels');
    if(setLabels){
      setLabels.style.setProperty('--set-count', String(matchCount * setsPerMatch));
      const parts = ['<span>Matchup</span>'];
      for(let m = 0; m < matchCount; m++){
        for(let s = 0; s < setsPerMatch; s++){
          const dividerAttr = m > 0 && s === 0 ? ' data-divider="true"' : '';
          const labelText = matchCount > 1 ? `M${m + 1} S${s + 1}` : `Set ${s + 1}`;
          parts.push(`<span data-match="${m}" data-set="${s}"${dividerAttr}>${labelText}</span>`);
        }
      }
      parts.push('<span>Total</span>');
      setLabels.innerHTML = parts.join('');
    }
    const matchTags = row.querySelector('.line-match-tags');
    if(matchTags){
      if(matchCount > 1){
        matchTags.innerHTML = matchData.map((match, idx) => {
          const label = match && typeof match.label === 'string' && match.label.trim() ? match.label.trim() : `Match ${idx + 1}`;
          return `<span data-match="${idx}">${escapeHTML(label)}</span>`;
        }).join('');
        matchTags.classList.remove('hidden');
      } else {
        let extras = [];
        if(matchTags.dataset.extraTags){
          try {
            const parsed = JSON.parse(matchTags.dataset.extraTags);
            if(Array.isArray(parsed)) extras = parsed.filter(Boolean);
          } catch(err){ extras = []; }
        }
        if(extras.length){
          matchTags.innerHTML = extras.map(tag => `<span>${escapeHTML(tag)}</span>`).join('');
          matchTags.classList.remove('hidden');
        } else {
          matchTags.innerHTML = '';
          matchTags.classList.add('hidden');
        }
      }
    }
    [1,2].forEach(team => {
      const container = row.querySelector(`.line-set-inputs[data-team="${team}"]`);
      if(!container) return;
      container.style.gridColumn = `2 / span ${matchCount * setsPerMatch}`;
      container.style.setProperty('--set-count', String(matchCount * setsPerMatch));
      container.innerHTML = '';
      for(let m = 0; m < matchCount; m++){
        for(let s = 0; s < setsPerMatch; s++){
          const field = document.createElement('div');
          field.className = 'set-field';
          field.dataset.match = String(m);
          field.dataset.set = String(s);
          if(m > 0 && s === 0) field.dataset.divider = 'true';

          const gamesInput = document.createElement('input');
          gamesInput.type = 'number';
          gamesInput.inputMode = 'numeric';
          gamesInput.className = 'set-input';
          gamesInput.min = '0';
          gamesInput.max = String(MAX_SET_GAMES);
          gamesInput.step = '1';
          gamesInput.dataset.team = String(team);
          gamesInput.dataset.match = String(m);
          gamesInput.dataset.set = String(s);
          const matchInfo = matchData[m];
          const matchLabel = matchCount > 1
            ? `${(matchInfo && typeof matchInfo.label === 'string' && matchInfo.label.trim() ? matchInfo.label.trim() : `Match ${m + 1}`)} `
            : '';
          gamesInput.setAttribute('aria-label', `${team === 1 ? 'Team 1' : 'Team 2'} ${matchLabel}set ${s + 1} games`);

          const preset = matchData[m] && Array.isArray(matchData[m].sets) ? matchData[m].sets[s] : null;
          if(preset){
            const value = team === 1 ? preset.team1 : preset.team2;
            if(Number.isInteger(Number(value))){
              gamesInput.value = Number(value);
            }
          }
          gamesInput.addEventListener('input', () => updateLineTotals(row));
          field.appendChild(gamesInput);

          const tieWrap = document.createElement('div');
          tieWrap.className = 'tie-break hidden';
          tieWrap.dataset.match = String(m);
          tieWrap.dataset.set = String(s);
          if(m > 0 && s === 0) tieWrap.dataset.divider = 'true';

          const tieLabel = document.createElement('span');
          tieLabel.className = 'tie-label';
          tieLabel.textContent = 'TB';

          const tieInput = document.createElement('input');
          tieInput.type = 'number';
          tieInput.inputMode = 'numeric';
          tieInput.className = 'tie-input';
          tieInput.min = '0';
          tieInput.max = '30';
          tieInput.step = '1';
          tieInput.dataset.team = String(team);
          tieInput.dataset.match = String(m);
          tieInput.dataset.set = String(s);
          tieInput.setAttribute('aria-label', `${team === 1 ? 'Team 1' : 'Team 2'} ${matchLabel}tiebreak points`);

          if(preset && preset.tieBreak){
            const tieVal = team === 1 ? preset.tieBreak.team1 : preset.tieBreak.team2;
            if(Number.isInteger(Number(tieVal))){
              tieInput.value = Number(tieVal);
              tieWrap.classList.remove('hidden');
            }
          }

          tieInput.addEventListener('input', () => updateLineTotals(row));
          tieWrap.append(tieLabel, tieInput);
          field.appendChild(tieWrap);
          container.appendChild(field);
        }
      }
    });
    updateLineTotals(row);
  }

  function makeLineRow(label='', sets=[], config={}){
    const row = document.createElement('div');
    row.className = 'line-row';

    const header = document.createElement('div');
    header.className = 'line-row-header';

    const labelInput = document.createElement('input');
    labelInput.type = 'text';
    labelInput.className = 'line-label';
    labelInput.placeholder = 'Court or matchup (e.g. Line 1 Singles)';
    labelInput.value = label;

    const typeSelect = document.createElement('select');
    typeSelect.className = 'line-type-select';
    typeSelect.innerHTML = `
      <option value="doubles">Doubles</option>
      <option value="singles">Singles</option>
    `;

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'line-remove';
    removeBtn.title = 'Remove court';
    removeBtn.textContent = '✕';
    const fixed = config && config.fixed;
    if(!fixed){
      removeBtn.addEventListener('click', () => {
        row.remove();
        if(!lineContainer.children.length){
          addDefaultLines();
        } else {
          refreshAllLineTeamLabels();
        }
        enforceUniquePlayers(1);
        enforceUniquePlayers(2);
      });
    } else {
      removeBtn.disabled = true;
      removeBtn.style.display = 'none';
    }

    if(config && config.tags && Array.isArray(config.tags) && config.tags.length){
      labelInput.value = label || config.tags.join(' • ');
    }

    header.append(labelInput, typeSelect, removeBtn);

    const scorecard = document.createElement('div');
    scorecard.className = 'line-scorecard';

    const matchTags = document.createElement('div');
    matchTags.className = 'line-match-tags hidden';
    if(Array.isArray(config.tags) && config.tags.length){
      matchTags.dataset.extraTags = JSON.stringify(config.tags);
    }
    scorecard.appendChild(matchTags);

    const setLabels = document.createElement('div');
    setLabels.className = 'line-set-labels';
    scorecard.appendChild(setLabels);

    const playersConfig = config && typeof config === 'object' && config.players ? config.players : {};
    const presetPlayers = {
      1: Array.isArray(playersConfig.team1) ? playersConfig.team1.slice(0,2) : [],
      2: Array.isArray(playersConfig.team2) ? playersConfig.team2.slice(0,2) : []
    };

    const initialModeRaw = config && typeof config.type === 'string' ? config.type : inferLineMode(label);
    const initialMode = initialModeRaw === 'singles' ? 'singles' : 'doubles';
    row.dataset.mode = initialMode;
    typeSelect.value = initialMode;
    if(fixed){
      typeSelect.disabled = true;
      typeSelect.classList.add('disabled');
    }
    if(config && typeof config.role === 'string'){
      row.dataset.matchRole = config.role;
    }

    const matchesConfig = config && typeof config === 'object' ? config.matches : null;
    const prefillMatches = buildMatchPrefill(initialMode, matchesConfig, sets);

    if(!fixed){
      typeSelect.addEventListener('change', () => {
        const previousMode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
        const existingValues = captureLineInputValues(row, previousMode);
        const nextMode = typeSelect.value === 'singles' ? 'singles' : 'doubles';
        row.dataset.mode = nextMode;
        applyPlayerSlotMode(row);
        refreshLinePlayersForRow(row);
        renderLineSetStructure(row, previousMode === nextMode ? existingValues : null);
      });
    }

    const buildSide = (team) => {
      const side = document.createElement('div');
      side.className = 'line-side';
      side.dataset.team = String(team);

      const info = document.createElement('div');
      info.className = 'line-side-info';

      const avatar = document.createElement('div');
      avatar.className = 'line-side-avatar';
      avatar.dataset.team = String(team);
      avatar.textContent = team;

      const infoText = document.createElement('div');

      const name = document.createElement('div');
      name.className = 'line-team-label';
      name.dataset.team = String(team);
      name.textContent = team === 1 ? 'Team 1' : 'Team 2';

      const status = document.createElement('div');
      status.className = 'line-team-status';
      status.dataset.team = String(team);
      status.dataset.defaultStatus = 'LINEUP';
      status.textContent = status.dataset.defaultStatus;

      infoText.append(name, status);
      info.append(avatar, infoText);

      const playerSummary = document.createElement('div');
      playerSummary.className = 'line-player-summary';
      playerSummary.dataset.team = String(team);
      playerSummary.textContent = 'Lineup: —';

      const setInputs = document.createElement('div');
      setInputs.className = 'line-set-inputs';
      setInputs.dataset.team = String(team);

      const total = document.createElement('div');
      total.className = 'line-total';
      total.dataset.team = String(team);
      total.textContent = '—';

      if(config && config.disablePlayerPicker){
        side.append(info, playerSummary, setInputs, total);
      } else {
        const playerPicker = document.createElement('div');
        playerPicker.className = 'player-picker';
        playerPicker.dataset.team = String(team);

        const savedList = presetPlayers[team];
        for(let i = 0; i < 2; i++){
          const field = document.createElement('label');
          field.className = 'player-field';
          field.dataset.team = String(team);
          field.dataset.slot = String(i);

          const slotLabel = document.createElement('span');
          slotLabel.className = 'player-slot-label';
          slotLabel.textContent = `Player ${i + 1}`;

          const playerSelect = document.createElement('select');
          playerSelect.className = 'player-select';
          playerSelect.dataset.team = String(team);
          playerSelect.dataset.slot = String(i);
          playerSelect.disabled = true;
          if(savedList && savedList[i]){
            playerSelect.dataset.initialValue = savedList[i];
          }
          playerSelect.addEventListener('change', () => {
            updateLineupSummary(row, team);
            enforceUniquePlayers(team);
          });

          field.append(slotLabel, playerSelect);
          playerPicker.appendChild(field);
        }

        side.append(info, playerPicker, playerSummary, setInputs, total);
      }
      return side;
    };

    scorecard.appendChild(buildSide(1));
    scorecard.appendChild(buildSide(2));

    row.append(header, scorecard);

    applyPlayerSlotMode(row);
    refreshLineTeamLabelsForRow(row);
    refreshLinePlayersForRow(row);
    renderLineSetStructure(row, prefillMatches);

    return row;
  }

  function addDefaultLines(){
    lineContainer.innerHTML = '';
    DEFAULT_LINES.forEach(entry => {
      const role = entry.role || '';
      const meta = MATCH_ROLE_DETAILS[role] || {};
      const matches = Array.isArray(meta.matchLabels)
        ? meta.matchLabels.map((label, idx) => ({ label: label || `Match ${idx + 1}` }))
        : null;
      const row = makeLineRow(meta.label || entry.label || `Court ${lineContainer.children.length + 1}`, [], {
        type: meta.type || entry.type || inferLineMode(meta.label || entry.label),
        tags: meta.tags,
        role,
        matches,
        fixed: true,
        disablePlayerPicker: true
      });
      lineContainer.appendChild(row);
    });
    refreshAllLineTeamLabels();
    updateAllLineupSummaries();
  }

  function clearLineScores(){
    Array.from(lineContainer.querySelectorAll('.line-row')).forEach(row => {
      row.querySelectorAll('.set-input').forEach(input => { input.value = ''; });
      row.querySelectorAll('.tie-input').forEach(input => { input.value = ''; });
      updateLineupSummary(row, 1);
      updateLineupSummary(row, 2);
      updateLineTotals(row);
    });
    resetLineupForTeam(1);
    resetLineupForTeam(2);
    refreshLineupOptions(1);
    refreshLineupOptions(2);
  }

  addDefaultLines();

  refreshLineupOptions(1);
  refreshLineupOptions(2);
  updateAllLineupSummaries();

  resetLinesBtn.addEventListener('click', () => {
    addDefaultLines();
  });

  dreambreakerToggle.addEventListener('change', () => {
    const on = dreambreakerToggle.checked;
    dreambreakerFields.classList.toggle('hidden', !on);
    if(!on){
      dreambreakerTeam1.value = '';
      dreambreakerTeam2.value = '';
    }
  });

  function collectCourtData(){
    const rows = Array.from(lineContainer.querySelectorAll('.line-row'));
    const lines = [];
    let total1 = 0, total2 = 0;
    let totalSets1 = 0, totalSets2 = 0;
    for(let i=0; i<rows.length; i++){
      const row = rows[i];
      const labelInput = row.querySelector('.line-label');
      const label = (labelInput && labelInput.value ? labelInput.value : '').trim() || `Court ${i+1}`;
      const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
      const meta1 = getSelectedTeamMeta(1);
      const meta2 = getSelectedTeamMeta(2);
      const roleConfig = getRoleConfig(row);
      const structure = getLineStructure(mode);
      const matchCount = structure.matches;
      const setsPerMatch = structure.sets;
      const matches = [];
      const pairings = { team1: [], team2: [] };
      for(let matchIdx = 0; matchIdx < matchCount; matchIdx++){
        const matchSets = [];
        let matchSeenAny = false;
        for(let setIdx = 0; setIdx < setsPerMatch; setIdx++){
          const input1 = row.querySelector(`.set-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
          const input2 = row.querySelector(`.set-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
          if(!input1 || !input2) continue;
          const raw1 = input1.value.trim();
          const raw2 = input2.value.trim();
          if(raw1 === '' && raw2 === '') continue;
          matchSeenAny = true;
          if(raw1 === '' || raw2 === ''){
            return { ok:false, msg:`Complete both scores for Match ${matchIdx + 1} Set ${setIdx + 1} on ${label}.` };
          }
          const val1 = Number(raw1);
          const val2 = Number(raw2);
          if(!Number.isInteger(val1) || !Number.isInteger(val2)){
            return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} must use whole numbers.` };
          }
          if(val1 < 0 || val2 < 0){
            return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} cannot be negative.` };
          }
          if(val1 > MAX_SET_GAMES || val2 > MAX_SET_GAMES){
            return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} is played to ${MAX_SET_GAMES} games.` };
          }
          if(val1 !== val2){
            const winnerScore = Math.max(val1, val2);
            const loserScore = Math.min(val1, val2);
            if(winnerScore !== MAX_SET_GAMES){
              return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} must be won with ${MAX_SET_GAMES} games.` };
            }
            if(loserScore > TIE_TRIGGER_GAMES){
              return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} cannot give the trailing team more than ${TIE_TRIGGER_GAMES} games.` };
            }
          } else {
            if(val1 !== TIE_TRIGGER_GAMES){
              return { ok:false, msg:`Match ${matchIdx + 1} Set ${setIdx + 1} on ${label} should be ${TIE_TRIGGER_GAMES}-${TIE_TRIGGER_GAMES} before a tiebreak.` };
            }
          }
          const entry = { set: setIdx + 1, team1: val1, team2: val2 };
          if(val1 === val2){
            const tieInput1 = row.querySelector(`.tie-input[data-team="1"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
            const tieInput2 = row.querySelector(`.tie-input[data-team="2"][data-match="${matchIdx}"][data-set="${setIdx}"]`);
            const tieRaw1 = tieInput1 ? tieInput1.value.trim() : '';
            const tieRaw2 = tieInput2 ? tieInput2.value.trim() : '';
            if(tieRaw1 === '' || tieRaw2 === ''){
              return { ok:false, msg:`Enter tiebreak points for Match ${matchIdx + 1} Set ${setIdx + 1} on ${label}.` };
            }
            const tie1 = Number(tieRaw1);
            const tie2 = Number(tieRaw2);
            if(!Number.isInteger(tie1) || !Number.isInteger(tie2)){
              return { ok:false, msg:`Tiebreak on Match ${matchIdx + 1} Set ${setIdx + 1} for ${label} must use whole numbers.` };
            }
            if(tie1 < 0 || tie2 < 0){
              return { ok:false, msg:`Tiebreak on Match ${matchIdx + 1} Set ${setIdx + 1} for ${label} cannot be negative.` };
            }
            if(tie1 > 30 || tie2 > 30){
              return { ok:false, msg:`Tiebreak on Match ${matchIdx + 1} Set ${setIdx + 1} for ${label} looks too high.` };
            }
            if(tie1 === tie2){
              return { ok:false, msg:`Tiebreak on Match ${matchIdx + 1} Set ${setIdx + 1} for ${label} needs a winner.` };
            }
            entry.tieBreak = { team1: tie1, team2: tie2 };
          }
          matchSets.push(entry);
        }
        if(matchSets.length){
          matches.push({ match: matchIdx + 1, label: `Match ${matchIdx + 1}`, sets: matchSets });
        } else if(matchSeenAny){
          return { ok:false, msg:`Finish entering scores for Match ${matchIdx + 1} on ${label}.` };
        }
      }
      if(matches.length === 0) continue;
      if(mode === 'doubles' && matches.length < matchCount){
        return { ok:false, msg:`Doubles on ${label} includes ${matchCount} matches. Complete each match score.` };
      }
      for(let matchIdx = 0; matchIdx < matches.length; matchIdx++){
        const players1 = getMatchPlayers(row, 1, matchIdx);
        const players2 = getMatchPlayers(row, 2, matchIdx);
        if(mode === 'singles'){
          if(players1.length !== 1){
            return { ok:false, msg:`Select a singles player for ${meta1.name} on ${label}.` };
          }
          if(players2.length !== 1){
            return { ok:false, msg:`Select a singles player for ${meta2.name} on ${label}.` };
          }
        } else {
          const team1Key = roleConfig && Array.isArray(roleConfig.team1Pairs) ? roleConfig.team1Pairs[matchIdx] : null;
          const team2Key = roleConfig && Array.isArray(roleConfig.team2Pairs) ? roleConfig.team2Pairs[matchIdx] : null;
          if(players1.length !== 2){
            const pairLabel = team1Key === 'pair2' ? 'Doubles Pair 2' : 'Doubles Pair 1';
            return { ok:false, msg:`${meta1.name}: ${pairLabel} needs two players before scoring ${label}.` };
          }
          if(players2.length !== 2){
            const pairLabel = team2Key === 'pair2' ? 'Doubles Pair 2' : 'Doubles Pair 1';
            return { ok:false, msg:`${meta2.name}: ${pairLabel} needs two players before scoring ${label}.` };
          }
        }
        pairings.team1.push({ match: matchIdx + 1, players: players1.slice() });
        pairings.team2.push({ match: matchIdx + 1, players: players2.slice() });
      }
      const flattenedSets = [];
      let totals = { team1:0, team2:0, sets1:0, sets2:0 };
      matches.forEach((match, matchIdx) => {
        const matchTotals = computeLineTotalsFromSets(match.sets);
        totals.team1 += matchTotals.team1;
        totals.team2 += matchTotals.team2;
        totals.sets1 += matchTotals.sets1;
        totals.sets2 += matchTotals.sets2;
        match.sets.forEach((set, setIdx) => {
          const payload = { set: flattenedSets.length + 1, team1: set.team1, team2: set.team2, match: match.match || (matchIdx + 1), matchSet: set.set || (setIdx + 1) };
          if(set.tieBreak){
            payload.tieBreak = { team1: set.tieBreak.team1, team2: set.tieBreak.team2 };
          }
          flattenedSets.push(payload);
        });
      });
      const team1Players = getLinePlayers(row, 1);
      const team2Players = getLinePlayers(row, 2);
      const matchesPayload = matches.map((match, matchIdx) => ({
        match: match.match || (matchIdx + 1),
        label: match.label,
        sets: match.sets.map((set, setIdx) => {
          const payload = { set: set.set || (setIdx + 1), team1: set.team1, team2: set.team2 };
          if(set.tieBreak){
            payload.tieBreak = { team1: set.tieBreak.team1, team2: set.tieBreak.team2 };
          }
          return payload;
        })
      }));

      const linePayload = {
        label,
        g1: totals.team1,
        g2: totals.team2,
        sets: flattenedSets,
        matches: matchesPayload,
        type: mode,
        setWins: { team1: totals.sets1, team2: totals.sets2 },
        players: { team1: team1Players, team2: team2Players }
      };
      if(row.dataset.matchRole){
        linePayload.role = row.dataset.matchRole;
      }
      if(pairings.team1.length || pairings.team2.length){
        linePayload.pairings = {
          team1: pairings.team1.map(entry => ({ match: entry.match, players: entry.players })),
          team2: pairings.team2.map(entry => ({ match: entry.match, players: entry.players }))
        };
      }
      lines.push(linePayload);
      total1 += totals.team1;
      total2 += totals.team2;
      totalSets1 += totals.sets1;
      totalSets2 += totals.sets2;
    }
    if(lines.length === 0){
      return { ok:false, msg:'Enter at least one set score.' };
    }
    return { ok:true, lines, total1, total2, sets1: totalSets1, sets2: totalSets2 };
  }

  function collectDreambreaker(){
    if(!dreambreakerToggle.checked) return { ok:true, dreambreaker:null };
    const a = dreambreakerTeam1.value.trim();
    const b = dreambreakerTeam2.value.trim();
    if(a === '' || b === ''){
      return { ok:false, msg:'Enter dreambreaker points for both teams.' };
    }
    const g1 = Number(a), g2 = Number(b);
    if(!Number.isInteger(g1) || !Number.isInteger(g2)){
      return { ok:false, msg:'Dreambreaker points must be whole numbers.' };
    }
    if(g1 < 0 || g2 < 0){
      return { ok:false, msg:'Dreambreaker points cannot be negative.' };
    }
    if(g1 === g2){
      return { ok:false, msg:'Dreambreaker cannot end in a tie.' };
    }
    if(g1 > 30 || g2 > 30){
      return { ok:false, msg:'Dreambreaker points look too high.' };
    }
    return { ok:true, dreambreaker:{ g1, g2 } };
  }

  /* ==========
     Derive standings from history
     ========== */
  function computeMatchSetTotals(match){
    if(!match) return { team1:0, team2:0 };
    let s1 = Number(match.s1);
    let s2 = Number(match.s2);
    if(!Number.isInteger(s1) || !Number.isInteger(s2)){
      const setsObj = match.sets && typeof match.sets === 'object' ? match.sets : null;
      if(setsObj){
        const raw1 = Number(setsObj.team1 ?? setsObj.t1 ?? setsObj.a ?? setsObj.w1);
        const raw2 = Number(setsObj.team2 ?? setsObj.t2 ?? setsObj.b ?? setsObj.w2);
        if(Number.isInteger(raw1) && Number.isInteger(raw2)){
          s1 = raw1;
          s2 = raw2;
        }
      }
    }
    if(!Number.isInteger(s1) || !Number.isInteger(s2)){
      if(Array.isArray(match.lines)){
        const totals = match.lines.reduce((acc,line)=>{
          const wins = deriveLineSetWins(line);
          acc.team1 += wins.team1;
          acc.team2 += wins.team2;
          return acc;
        }, { team1:0, team2:0 });
        s1 = totals.team1;
        s2 = totals.team2;
      }
    }
    s1 = Number.isInteger(s1) && s1 >= 0 ? s1 : 0;
    s2 = Number.isInteger(s2) && s2 >= 0 ? s2 : 0;
    return { team1:s1, team2:s2 };
  }

  function computeStandings(){
    const stats = {};
    TEAMS.forEach(n => stats[n] = {
      team:n,
      matches:0,
      wins:0,
      losses:0,
      setsFor:0,
      setsAgainst:0,
      gamesFor:0,
      gamesAgainst:0,
      points:0
    });
    for(const m of matches){
      if(!stats[m.t1] || !stats[m.t2]) continue;
      // increment matches
      stats[m.t1].matches++; stats[m.t2].matches++;
      // games
      stats[m.t1].gamesFor += m.g1; stats[m.t1].gamesAgainst += m.g2;
      stats[m.t2].gamesFor += m.g2; stats[m.t2].gamesAgainst += m.g1;
      const setTotals = computeMatchSetTotals(m);
      stats[m.t1].setsFor += setTotals.team1; stats[m.t1].setsAgainst += setTotals.team2;
      stats[m.t2].setsFor += setTotals.team2; stats[m.t2].setsAgainst += setTotals.team1;
      if(m.win === m.t1){
        stats[m.t1].wins++; stats[m.t2].losses++;
        stats[m.t1].points++;
      } else if(m.win === m.t2){
        stats[m.t2].wins++; stats[m.t1].losses++;
        stats[m.t2].points++;
      }
    }
    Object.values(stats).forEach(s => {
      s.setDiff = s.setsFor - s.setsAgainst;
      s.gameDiff = s.gamesFor - s.gamesAgainst;
    });
    // sort: Match points → Set differential → Sets for → Game differential → Games for → Name
    const arr = Object.values(stats)
      .sort((a,b)=>
        (b.points - a.points) ||
        (b.setDiff - a.setDiff) ||
        (b.setsFor - a.setsFor) ||
        (b.gameDiff - a.gameDiff) ||
        (b.gamesFor - a.gamesFor) ||
        a.team.localeCompare(b.team)
      );
    return arr;
  }

  function renderStandings(){
    if(!matchesLoaded){
      standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">Loading standings from Firebase…</td></tr>';
      return;
    }

    const rows = computeStandings();

    if(matches.length === 0){
      standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">No results yet. Add a match to see standings.</td></tr>';
      return;
    }

    standingsBody.innerHTML = rows.map((r,i)=>`
      <tr class="${i<4?'qualified':''}">
        <td class="rank-cell" data-label="Rank">${i+1}</td>
        <td class="team-cell" data-label="Team">${r.team}</td>
        <td class="center-cell" data-label="Matches">${r.matches}</td>
        <td class="center-cell" data-label="Match Wins">${r.wins}</td>
        <td class="center-cell" data-label="Match Losses">${r.losses}</td>
        <td class="center-cell" data-label="Sets Won">${r.setsFor}</td>
        <td class="center-cell" data-label="Sets Lost">${r.setsAgainst}</td>
        <td class="center-cell" data-label="Set Diff">${r.setDiff}</td>
        <td class="center-cell" data-label="Games Won">${r.gamesFor}</td>
        <td class="center-cell" data-label="Games Lost">${r.gamesAgainst}</td>
        <td class="center-cell" data-label="Game Diff">${r.gameDiff}</td>
        <td class="points-cell" data-label="Match Points">${r.points}</td>
      </tr>
    `).join('');
  }

  function renderHistory(){
    if(!matchesLoaded){
      historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">Loading match history from Firebase…</td></tr>';
      return;
    }
    if(matches.length === 0){
      historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">No matches recorded.</td></tr>';
      return;
    }
    historyBody.innerHTML = matches.map((m,idx)=>{
      const matchSets = computeMatchSetTotals(m);
      const setsLabel = (matchSets.team1 + matchSets.team2) > 0 ? ` (${matchSets.team1}-${matchSets.team2} sets)` : '';
      const breakdown = Array.isArray(m.lines) && m.lines.length
        ? `<details><summary>Courts (${m.lines.length})${m.dreambreaker ? ' • Dreambreaker' : ''}</summary>${m.lines.map(line=>{
            const sets = formatLineSets(line, { html:true });
            const players = formatLinePlayers(line, m);
            return `<div class="history-line">${escapeHTML(line.label)}: ${line.g1}-${line.g2}${sets}${players}</div>`;
          }).join('')}${m.dreambreaker ? `<div class="history-line"><strong>Dreambreaker:</strong> ${m.dreambreaker.g1}-${m.dreambreaker.g2}</div>` : ''}</details>`
        : (m.dreambreaker ? `Dreambreaker ${m.dreambreaker.g1}-${m.dreambreaker.g2}` : '—');
      return `
      <tr>
        <td class="rank-cell" data-label="Match #">${matches.length - idx}</td>
        <td class="team-cell" data-label="Teams">${m.t1} vs ${m.t2}</td>
        <td class="center-cell" data-label="Games (Sets)">${m.g1}-${m.g2}${setsLabel}</td>
        <td class="points-cell" data-label="Winner">${m.win}</td>
        <td data-label="Breakdown">${breakdown}</td>
        <td class="center-cell" data-label="Date/Time">${new Date(m.ts).toLocaleString()}</td>
      </tr>
    `; }).join('');
  }

  function renderAll(){
    renderStandings();
    renderHistory();
  }

  /* ==========
     Actions: Add / Undo / Clear / Import / Export
     ========== */
  document.getElementById('addBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Please wait for existing results to load.');
    const a = t1.value.trim(), b = t2.value.trim();
    if(!a || !b) return alert('Select both teams.');
    if(a === b) return alert('A team cannot play itself.');

    const courts = collectCourtData();
    if(!courts.ok) return alert('⚠️ ' + courts.msg);

    const dream = collectDreambreaker();
    if(!dream.ok) return alert('⚠️ ' + dream.msg);

    const total1 = courts.total1;
    const total2 = courts.total2;
    const sets1 = courts.sets1;
    const sets2 = courts.sets2;

    let win;
    if(total1 > total2){
      win = a;
    } else if(total2 > total1){
      win = b;
    } else {
      if(!dream.dreambreaker) return alert('⚠️ Totals are tied. Enter the dreambreaker result.');
      win = dream.dreambreaker.g1 > dream.dreambreaker.g2 ? a : b;
    }

    const record = {
      t1:a,
      t2:b,
      g1: total1,
      g2: total2,
      s1: sets1,
      s2: sets2,
      win,
      ts: Date.now(),
      lines: courts.lines
    };
    record.sets = { team1: sets1, team2: sets2 };
    if(dream.dreambreaker) record.dreambreaker = dream.dreambreaker;

    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.push(record);

      // Clear inputs after successful save
      t1.value = '';
      t2.value = '';
      clearLineScores();
      refreshAllLineTeamLabels();
      dreambreakerToggle.checked = false;
      dreambreakerFields.classList.add('hidden');
      dreambreakerTeam1.value = '';
      dreambreakerTeam2.value = '';

      const setNote = (sets1 + sets2) > 0 ? `\nSets: ${sets1}-${sets2}` : '';
      const dreamNote = record.dreambreaker ? `\nDreambreaker: ${record.dreambreaker.g1}-${record.dreambreaker.g2}` : '';
      alert(`✅ Saved: ${a} ${record.g1}-${record.g2} ${b}\nWinner: ${win} (+1 match point)${setNote}${dreamNote}`);
    } catch(err){
      console.error('Failed to save match', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('❌ Failed to save match. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('undoBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    if(matches.length === 0) return alert('Nothing to undo.');
    const last = matches[0];
    const matchSets = computeMatchSetTotals(last);
    const setsLine = (matchSets.team1 + matchSets.team2) > 0 ? `\nSets: ${matchSets.team1}-${matchSets.team2}` : '';
    const courts = Array.isArray(last.lines) && last.lines.length ? '\nCourts: ' + last.lines.map(l=>{
      const sets = formatLineSets(l);
      const players = formatLinePlayersText(l, last);
      const playersNote = players ? ` [${players}]` : '';
      return `${l.label} ${l.g1}-${l.g2}${sets}${playersNote}`;
    }).join('; ') : '';
    const dream = last.dreambreaker ? `\nDreambreaker ${last.dreambreaker.g1}-${last.dreambreaker.g2}` : '';
    if(!confirm(`Undo last match?\n${last.t1} ${last.g1}-${last.g2} ${last.t2}${setsLine}${courts}${dream}`)) return;
    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.child(last.id).remove();
    } catch(err){
      console.error('Failed to undo match', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('❌ Failed to undo match. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('clearBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    if(matches.length === 0) return alert('Nothing to clear.');
    if(!confirm('Clear ALL match results?')) return;
    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.remove();
    } catch(err){
      console.error('Failed to clear matches', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('❌ Failed to clear matches. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('exportBtn').addEventListener('click', () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    const payload = matches.map(({id, ...rest}) => rest);
    const blob = new Blob([JSON.stringify(payload,null,2)], { type:'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'koc-season2-matches.json';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  document.getElementById('importFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async () => {
      try{
        const data = JSON.parse(reader.result);
        if(!Array.isArray(data)) throw new Error('Invalid JSON shape');
        // quick sanity check
        const upgraded = data.map(entry => {
          const u = upgradeMatch(entry);
          if(!u) throw new Error('Malformed match entry (invalid games)');
          if(!TEAMS.includes(u.t1) || !TEAMS.includes(u.t2)) throw new Error('Unknown team in data');
          if(u.win !== u.t1 && u.win !== u.t2) throw new Error('Match is missing a winner');
          const { id, ...clean } = u;
          return clean;
        });
        if(!(await guardWriteAccess())) return;

        if(upgraded.length === 0){
          await matchesRef.set(null);
        } else {
          const updates = {};
          upgraded.forEach(entry => {
            const key = matchesRef.push().key;
            updates[key] = entry;
          });
          await matchesRef.set(updates);
        }
        alert('✅ Import successful.');
      } catch(err){
        console.error(err);
        if(err && err.code === 'PERMISSION_DENIED'){
          authReady = false;
          authError = err;
        }
        alert('❌ Import failed: ' + err.message);
      } finally {
        e.target.value = '';
      }
    };
    reader.onerror = () => {
      alert('❌ Failed to read file.');
      e.target.value = '';
    };
    reader.readAsText(file);
  });

  /* ==========
     Initial render
     ========== */
  renderAll();
</script>
</body>
</html>