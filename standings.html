<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings - KOC Season 2</title>
  <style>
    /* ===== Base / Theme (matches your site) ===== */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root{
      --bg1:#667eea; --bg2:#764ba2; --ink:#1a202c; --muted:#718096; --card:#ffffff;
      --ring:#e2e8f0; --accent:#22d3ee;
    }
    html,body{ height:100%; }
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      min-height:100vh; color:var(--ink);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Header & Nav ===== */
    .header{ position:sticky; top:0; z-index:50; backdrop-filter:blur(10px); }
    .header-bar{
      display:flex; align-items:center; justify-content:space-between;
      max-width:1100px; margin:0 auto; padding:.75rem 1rem;
      background:rgba(255,255,255,.95); box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    .brand{ display:flex; align-items:center; gap:.5rem; }
    .brand i{ font-size:1.5rem; }
    .brand strong{
      font-size:1.15rem; background:linear-gradient(135deg,var(--bg1),var(--bg2));
      -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
    }
    .menu-btn{ display:none; border:0; background:transparent; font-size:1.5rem; padding:.25rem .5rem; cursor:pointer; }
    nav.nav{
      max-width:1100px; margin:.35rem auto 0; display:flex; gap:.5rem; padding:.5rem 1rem;
      background:rgba(255,255,255,.9); border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    .nav a{
      text-decoration:none; color:#4a5568; font-weight:600;
      padding:.6rem 1rem; border-radius:8px; white-space:nowrap;
    }
    .nav a[aria-current="page"], .nav a:hover{
      color:#fff; background:linear-gradient(135deg,var(--bg1),var(--bg2));
    }

    /* ===== Layout ===== */
    .container{ max-width:1100px; margin:1rem auto 2rem; padding:0 1rem; }
    .page-header{
      background:#fff; border-radius:12px; padding:1.25rem 1.5rem; margin-bottom:1rem;
      box-shadow:0 2px 8px rgba(0,0,0,.08); border-left:4px solid var(--accent);
      text-align:center;
    }
    .page-header h1{ font-size:1.9rem; margin-bottom:.25rem; }
    .page-header p{ color:var(--muted); }

    .card{
      background:#fff; border-radius:12px; padding:1.25rem 1.5rem; margin-bottom:1rem;
      box-shadow:0 4px 12px rgba(0,0,0,.1);
    }
    .card h2{ margin-bottom:1rem; }

    /* ===== Access & Forms ===== */
    .access-card{ border:2px solid var(--accent); text-align:center; }
    .access-controls{ display:flex; gap:.6rem; justify-content:center; align-items:center; flex-wrap:wrap; }
    .access-input{
      padding:.7rem 1rem; border:2px solid var(--ring); border-radius:8px; min-width:240px;
    }
    .access-input:focus{ outline:none; border-color:var(--accent); }
    .btn{
      padding:.7rem 1.2rem; border:none; border-radius:8px; font-weight:800; color:#fff; cursor:pointer;
      background:linear-gradient(135deg,var(--bg1),var(--bg2)); box-shadow:0 2px 10px rgba(102,126,234,.35);
    }
    .btn.secondary{ background:#64748b; box-shadow:none; }
    .btn.success{ background:linear-gradient(135deg,#10b981,#059669); box-shadow:0 2px 10px rgba(16,185,129,.35); }
    .btn.warn{ background:linear-gradient(135deg,#f59e0b,#d97706); }
    .btn.danger{ background:linear-gradient(135deg,#ef4444,#dc2626); }
    .btn.ghost{ background:#fff; color:#1f2937; border:2px solid var(--ring); box-shadow:none; }

    .scoring-card{ border:2px solid var(--accent); background:linear-gradient(135deg,#f8fafc 0%,#f1f5f9 100%); }
    .card-header{ display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap; }
    .tools{ display:flex; gap:.5rem; flex-wrap:wrap; }

    .match-form{
      display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:1rem; align-items:start; margin-top:.25rem;
    }
    .team-input{
      display:flex; flex-direction:column; gap:.6rem; background:#fff; padding:1rem; border-radius:10px; border:2px solid var(--ring);
    }
    .input-label{ font-weight:800; text-align:center; }
    .select-input,.number-input,.text-input{
      padding:.7rem; border:2px solid var(--ring); border-radius:8px;
    }
    .select-input:focus,.number-input:focus,.text-input:focus{ outline:none; border-color:var(--accent); }
    .inline{ display:flex; gap:.5rem; align-items:center; justify-content:space-between; }

    .legend{ color:var(--muted); font-size:.9rem; margin-top:.5rem; text-align:center; }

    .line-editor{
      background:#fff; border-radius:16px; border:2px dashed rgba(34,211,238,.6); padding:1.25rem; display:flex; flex-direction:column; gap:1rem;
    }
    .line-header{ display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap; }
    .line-actions{ display:flex; gap:.5rem; flex-wrap:wrap; }
    .line-list{ display:flex; flex-direction:column; gap:.85rem; }
    .line-row{
      background:linear-gradient(135deg,#f8fafc 0%,#eef2ff 100%);
      border-radius:18px; padding:1rem 1.1rem; box-shadow:0 6px 18px rgba(15,23,42,.12);
      display:flex; flex-direction:column; gap:.9rem; position:relative;
    }
    .line-row::before{
      content:""; position:absolute; inset:0; border-radius:18px; padding:1px; pointer-events:none;
      background:linear-gradient(135deg,rgba(34,211,238,.8),rgba(102,126,234,.8)); -webkit-mask:
        linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
    }
    .line-row-header{ display:flex; align-items:center; justify-content:space-between; gap:.75rem; }
    .line-row .line-label{
      font-weight:700; border-radius:12px; border:2px solid rgba(148,163,184,.4); padding:.65rem 1rem; flex:1;
      background:#fff; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    }
    .line-row .line-label:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25);
      background:#f8feff;
    }
    .line-type-select{
      border:2px solid rgba(148,163,184,.4); border-radius:12px; padding:.55rem .9rem; font-weight:700; color:#0f172a;
      background:#fff; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    }
    .line-type-select:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25); }
    .line-remove{ border:0; background:#fee2e2; color:#ef4444; font-size:1.15rem; cursor:pointer; padding:.35rem .6rem; border-radius:10px; transition:.2s ease; }
    .line-remove:hover{ background:#fecaca; color:#b91c1c; }
    .line-scorecard{
      background:#fff; border-radius:14px; padding:1rem 1.1rem 1.1rem 1.45rem; display:flex; flex-direction:column; gap:.75rem; position:relative; overflow:hidden;
    }
    .line-scorecard::before{
      content:""; position:absolute; left:0; top:0; bottom:0; width:4px; border-radius:14px 0 0 14px;
      background:linear-gradient(180deg,#22d3ee,#667eea);
    }
    .line-set-labels{
      display:grid; grid-template-columns:minmax(0,1.6fr) repeat(3, minmax(60px,1fr)) minmax(60px,.9fr);
      padding-left:.75rem; font-size:.75rem; text-transform:uppercase; letter-spacing:.1em; color:#64748b; font-weight:700;
    }
    .line-set-labels span{ text-align:center; }
    .line-set-labels span:first-child{ opacity:.7; text-align:left; }
    .line-side{
      display:grid; grid-template-columns:minmax(0,1.7fr) repeat(3, minmax(60px,1fr)) minmax(60px,.9fr);
      align-items:flex-start; justify-items:center; gap:.6rem; padding:.35rem .75rem;
    }
    .line-side > .line-side-info{ justify-self:start; }
    .line-side + .line-side{ border-top:1px solid rgba(148,163,184,.35); padding-top:.9rem; margin-top:.35rem; }
    .line-side-info{ display:flex; align-items:center; gap:.65rem; }
    .line-side-avatar{
      width:38px; height:38px; border-radius:50%; display:flex; align-items:center; justify-content:center;
      font-weight:800; background:linear-gradient(135deg,#667eea,#22d3ee); color:#fff; box-shadow:0 4px 10px rgba(79,70,229,.35);
    }
    .line-team-label{ font-weight:800; font-size:1rem; color:#1f2937; }
    .line-team-status{ font-size:.7rem; text-transform:uppercase; letter-spacing:.08em; color:#94a3b8; font-weight:800; margin-top:.15rem; }
    .line-team-status[data-state="incomplete"]{ color:#b45309; }
    .line-team-status[data-state="tied"]{ color:#b45309; }
    .line-team-status[data-state="winner"]{ color:#047857; }
    .player-picker{
      grid-column:1 / span 4; display:flex; flex-wrap:wrap; gap:.6rem; justify-content:flex-start; align-items:flex-start;
    }
    .player-field{ display:flex; flex-direction:column; gap:.25rem; min-width:140px; }
    .player-field.hidden{ display:none; }
    .player-slot-label{
      font-size:.7rem; text-transform:uppercase; letter-spacing:.08em; color:#64748b; font-weight:700;
    }
    .player-select{
      padding:.55rem .7rem; border:2px solid rgba(148,163,184,.4); border-radius:10px; background:#fff; font-weight:600;
      color:#0f172a;
    }
    .player-select:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.25); }
    .line-player-summary{
      grid-column:1 / span 4; justify-self:stretch; background:rgba(148,163,184,.18); color:#475569;
      font-size:.8rem; padding:.35rem .6rem; border-radius:8px; display:flex; flex-wrap:wrap; gap:.75rem;
    }
    .line-player-summary strong{ font-weight:800; color:#1f2937; }
    .line-players{ margin-top:.35rem; font-size:.8rem; color:#475569; display:flex; flex-direction:column; gap:.2rem; }
    .line-players span{ display:block; }
    .history-line{ margin-bottom:.5rem; }
    .history-line:last-child{ margin-bottom:0; }
    .line-set-inputs{ display:grid; grid-template-columns:repeat(3, minmax(60px,1fr)); gap:.45rem; grid-column:2 / span 3; }
    .set-field{ display:flex; flex-direction:column; align-items:center; gap:.35rem; }
    .set-input{
      width:100%; padding:.55rem 0; border:2px solid rgba(148,163,184,.4); border-radius:10px; text-align:center; font-weight:800;
      font-size:1rem; background:#f8fafc; transition:.2s ease; color:#0f172a;
    }
    .set-input:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,211,238,.2); background:#ecfeff; }
    .tie-break{ display:flex; align-items:center; gap:.35rem; font-size:.75rem; font-weight:700; color:#475569; }
    .tie-label{
      padding:.15rem .45rem; border-radius:999px; background:rgba(148,163,184,.2); letter-spacing:.05em;
    }
    .tie-input{
      width:3.25rem; padding:.35rem 0; border:2px solid rgba(148,163,184,.4); border-radius:8px; text-align:center; font-weight:700;
      font-size:.85rem; background:#fff; color:#0f172a;
    }
    .tie-input:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 2px rgba(34,211,238,.2); }
    .line-total{
      justify-self:center; font-weight:900; font-size:1.1rem; color:#1f2937; min-width:2.5rem; text-align:center; padding:.35rem .5rem;
      border-radius:10px; background:#f1f5f9;
    }
    .line-side.winner .line-team-status{ color:#047857; }
    .line-side.winner .line-total{ background:rgba(16,185,129,.15); color:#065f46; }
    .line-side.tied .line-team-status{ color:#b45309; }
    .line-side.tied .line-total{ background:rgba(251,191,36,.18); color:#92400e; }
    .line-hint{ color:var(--muted); font-size:.85rem; }
    .dreambreaker{ display:flex; flex-direction:column; gap:.5rem; }
    .dreambreaker-toggle{ display:flex; align-items:center; gap:.5rem; font-weight:600; }
    .dreambreaker-fields{ display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:.6rem; }
    .dreambreaker-fields .number-input{ width:100%; }
    .dreambreaker-note{ color:var(--muted); font-size:.85rem; }
    .history-breakdown-wrapper{ display:flex; flex-direction:column; gap:.4rem; }
    .history-toggle{
      display:inline-flex; align-items:center; gap:.35rem; font-weight:700; color:#2563eb;
      background:transparent; border:0; cursor:pointer; padding:0; font-size:.95rem;
    }
    .history-toggle:hover{ color:#1d4ed8; }
    .history-toggle:focus{ outline:2px solid rgba(37,99,235,.35); outline-offset:3px; border-radius:6px; }
    .history-toggle::before{ content:'‚ñ∏'; transition:transform .2s ease; font-size:.9rem; }
    .history-toggle[aria-expanded="true"]::before{ transform:rotate(90deg); }
    .history-breakdown{
      display:none; background:rgba(148,163,184,.15); border-radius:10px; padding:.65rem .8rem;
      color:#475569; box-shadow:inset 0 1px 0 rgba(255,255,255,.6);
    }
    .history-breakdown.open{ display:block; }

    .form-actions{ display:flex; gap:.6rem; justify-content:center; flex-wrap:wrap; margin-top:1rem; }
    .hidden{ display:none; }

    /* ===== Tables ===== */
    .table-container{ overflow-x:auto; }
    table{ width:100%; border-collapse:collapse; background:#fff; border-radius:8px; overflow:hidden; }
    thead th{
      background:linear-gradient(135deg,#0f172a,#1e293b); color:#fff; padding:.85rem; text-align:left;
    }
    tbody td{ padding:.85rem; border-bottom:1px solid var(--ring); }
    tbody tr:hover{ background:#f8fafc; }

    .standings-table tr.qualified{ background:linear-gradient(90deg,#d1fae5 0%, transparent 100%); }
    .standings-table tr.qualified:hover{ background:linear-gradient(90deg,#a7f3d0 0%, #f8fafc 100%); }

    .usage-alert{ background:rgba(254,226,226,.7); }
    .usage-alert td{ color:#991b1b; font-weight:700; }
    .usage-alert td:first-child{ font-weight:800; }

    .rank-cell{ font-weight:900; }
    .team-cell{ font-weight:800; }
    .center-cell{ text-align:center; }
    .points-cell{ font-weight:900; }

    .hint{ color:var(--muted); font-size:.9rem; margin-top:.35rem; }

    /* ===== Mobile ===== */
    @media (max-width:1024px){
      .card-header,
      .line-header{ flex-direction:column; align-items:flex-start; }
      .tools,
      .line-actions{ width:100%; justify-content:flex-start; }
    }

    @media (max-width:768px){
      .menu-btn{ display:block; }
      nav.nav{ display:none; flex-direction:column; }
      nav.nav.open{ display:flex; }
      .container{ padding:0 .75rem; }
      .match-form{ grid-template-columns:1fr; }
      .form-actions .btn,
      .access-controls .btn{ width:100%; }
      .card{ padding:1rem; }
      .access-controls{ flex-direction:column; align-items:stretch; }
      .access-input{ width:100%; min-width:0; }
      .tools .btn,
      .line-actions .btn{ width:100%; }
      .line-set-labels{ grid-template-columns:minmax(0,1fr) repeat(3, minmax(48px,1fr)) minmax(48px,.8fr); padding-left:.25rem; }
      .line-side{ grid-template-columns:minmax(0,1fr) repeat(3, minmax(48px,1fr)) minmax(48px,.8fr); padding:.5rem .5rem; }
      .line-set-inputs{ grid-template-columns:repeat(3, minmax(48px,1fr)); gap:.35rem; }
      .tie-input{ width:2.75rem; }
      .line-side-avatar{ width:34px; height:34px; font-size:.95rem; }
      .line-team-label{ font-size:.95rem; }
    }

    @media (max-width:640px){
      .page-header h1{ font-size:1.6rem; }
      .line-row{ padding:1rem; }
      .player-picker{ flex-direction:column; align-items:stretch; }
      .player-field{ min-width:0; width:100%; }
      .line-scorecard{ padding:1rem; }
      .line-set-labels{ display:none; }
      .line-side{ grid-template-columns:minmax(0,1fr); gap:.65rem; padding:.75rem .5rem; justify-items:stretch; }
      .line-side > .line-side-info{ flex-wrap:wrap; }
      .line-side-info{ align-items:flex-start; }
      .line-set-inputs{ grid-column:1; width:100%; }
      .tie-break{ grid-column:1; justify-content:flex-start; }
      .line-total{ grid-column:1; justify-self:flex-start; align-self:flex-start; display:inline-flex; }
      .line-side + .line-side{ margin-top:.65rem; padding-top:.65rem; }
      .dreambreaker-fields{ grid-template-columns:1fr; }
      .form-actions{ flex-direction:column; }
      .responsive-table thead{ display:none; }
      .responsive-table tbody{ display:block; }
      .responsive-table tbody tr{ display:block; border:1px solid var(--ring); border-radius:12px; margin-bottom:1rem; box-shadow:0 4px 12px rgba(15,23,42,.08); overflow:hidden; background:#fff; }
      .responsive-table tbody tr:last-child{ margin-bottom:0; }
      .responsive-table tbody td{ display:flex; flex-direction:column; align-items:flex-start; gap:.35rem; padding:.75rem 1rem; border-bottom:1px solid var(--ring); }
      .responsive-table tbody td:last-child{ border-bottom:none; }
      .responsive-table tbody td::before{ content:attr(data-label); font-weight:700; font-size:.75rem; text-transform:uppercase; letter-spacing:.08em; color:var(--muted); }
      .responsive-table tbody td.rank-cell,
      .responsive-table tbody td.points-cell{ align-items:flex-end; text-align:right; }
      .responsive-table tbody td.center-cell{ align-items:flex-start; text-align:left; }
      .table-container{ margin:0 -.5rem; padding:0 .5rem; }
    }
  </style>
</head>
<body>
<!-- Header -->
<header class="header">
  <div class="header-bar">
    <div class="brand" aria-label="KOC Season 2">
      <i>üèÜ</i><strong>KOC Season 2</strong>
    </div>
    <button id="menuBtn" class="menu-btn" aria-expanded="false" aria-controls="siteNav" aria-label="Toggle Menu">‚ò∞</button>
  </div>
  <nav id="siteNav" class="nav" aria-label="Primary">
    <!-- Order you asked for: Teams ‚Üí Schedule ‚Üí Rules ‚Üí Standings -->
    <a href="index.html">üë• Teams</a>
    <a href="index22.html">üìÖ Schedule</a>
    <a href="rules.html">üìã Rules</a>
    <a href="standings.html" aria-current="page">üìä Standings</a>
  </nav>
</header>

<main class="container">
  <section class="page-header">
    <h1>Tournament Standings</h1>
    <p>Live rankings and match results (stored securely in Firebase)</p>
  </section>

  <!-- Access Code -->
  <section class="card access-card">
    <h2>üîí Score Entry Access</h2>
    <div class="access-controls" style="margin:.5rem 0;">
      <input type="password" id="accessCode" placeholder="Enter access code" class="access-input" />
      <button class="btn" id="unlockBtn">Unlock Scoring</button>
    </div>
    <p class="hint">Captains: enter the secure access code provided by the organizers. Data is saved in <em>Firebase</em>.</p>
  </section>

  <!-- Scoring Form -->
  <section id="scoringForm" class="card scoring-card hidden">
    <div class="card-header">
      <h2>üìù Add Match Result (Best-of-5)</h2>
      <div class="tools">
        <button class="btn secondary" id="lockBtn">Lock</button>
        <button class="btn ghost" id="exportBtn">Export JSON</button>
        <label class="btn ghost" for="importFile" style="cursor:pointer;">Import JSON</label>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>
    </div>

    <div class="match-form">
      <div class="team-input">
        <label class="input-label">Team 1</label>
        <select id="team1Name" class="select-input" required>
          <option value="">Select Team 1</option>
        </select>
      </div>
      <div class="team-input">
        <label class="input-label">Team 2</label>
        <select id="team2Name" class="select-input" required>
          <option value="">Select Team 2</option>
        </select>
      </div>
    </div>

    <div class="line-editor" aria-labelledby="courtLabel">
      <div class="line-header">
        <div id="courtLabel"><strong>Court Breakdown</strong> (enter games won per court)</div>
        <div class="line-actions">
          <button type="button" class="btn ghost" id="resetLinesBtn">Reset Courts</button>
          <button type="button" class="btn ghost" id="crossCourtBtn">Fill Cross Matches</button>
          <button type="button" class="btn ghost" id="addLineBtn">+ Add Court</button>
        </div>
      </div>
      <div id="lineContainer" class="line-list" aria-live="polite"></div>
      <p class="line-hint">Leave courts you didn't play empty or remove them. Pick your lineup from each roster, then enter set-by-set games &mdash; if a set ends level, tiebreak boxes will appear so you can record the breaker.</p>
    </div>

    <div class="dreambreaker">
      <label class="dreambreaker-toggle"><input type="checkbox" id="dreambreakerToggle" /> Dreambreaker played</label>
      <div id="dreambreakerFields" class="dreambreaker-fields hidden">
        <div>
          <label>Dreambreaker Points (Team 1)</label>
          <input type="number" id="dreambreakerTeam1" class="number-input" min="0" max="20" step="1" />
        </div>
        <div>
          <label>Dreambreaker Points (Team 2)</label>
          <input type="number" id="dreambreakerTeam2" class="number-input" min="0" max="20" step="1" />
        </div>
      </div>
      <p class="dreambreaker-note">Use the dreambreaker fields only if total games are tied. Winner still earns <strong>1 match point</strong>.</p>
    </div>

    <p class="legend">Universal Tennis Team format: total match winner is determined by <strong>games won across all courts</strong>. Lineups, set totals, and dreambreaker results are saved so standings can track match points, set differential, and game differential automatically.</p>

    <div class="form-actions">
      <button class="btn success" id="addBtn">Save Result</button>
      <button class="btn warn" id="undoBtn" title="Remove the most recent match">Undo Last</button>
      <button class="btn danger" id="clearBtn" title="Clear ALL results">Clear All</button>
    </div>
  </section>

  <!-- Standings -->
  <section class="card standings-card">
    <h2>üìä Current Standings</h2>
    <div class="table-container">
      <table class="standings-table responsive-table">
        <thead>
        <tr>
          <th>Rank</th>
          <th>Team</th>
          <th>Matches</th>
          <th>Match Wins</th>
          <th>Match Losses</th>
          <th>Sets Won</th>
          <th>Sets Lost</th>
          <th>Set Diff</th>
          <th>Games Won</th>
          <th>Games Lost</th>
          <th>Game Diff</th>
          <th>Match Points</th>
        </tr>
        </thead>
        <tbody id="standingsBody">
        <tr><td colspan="12" class="center-cell" style="color:var(--muted);">No results yet. Add a match to see standings.</td></tr>
        </tbody>
      </table>
    </div>
    <p class="hint">Sorted by Match Points ‚Üí Set Differential ‚Üí Sets Won ‚Üí Game Differential ‚Üí Games Won (top 4 highlighted).</p>
  </section>

  <!-- Match History -->
  <section class="card history-card">
    <h2>üìú Match History</h2>
    <div class="table-container">
      <table class="history-table responsive-table">
        <thead>
        <tr>
          <th>#</th>
          <th>Teams</th>
          <th>Games (Sets)</th>
          <th>Winner</th>
          <th>Breakdown</th>
          <th>Date/Time</th>
        </tr>
        </thead>
        <tbody id="historyBody">
        <tr><td colspan="6" class="center-cell" style="color:var(--muted);">No matches recorded.</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <!-- Player Participation -->
  <section class="card participation-card">
    <h2>üßë‚Äçü§ù‚Äçüßë Player Participation</h2>
    <p class="hint">Unique match days each player has appeared on. Rows highlight in red once a player reaches six days.</p>
    <div class="table-container">
      <table class="responsive-table">
        <thead>
        <tr>
          <th>#</th>
          <th>Team</th>
          <th>Player</th>
          <th>Match Days Played</th>
        </tr>
        </thead>
        <tbody id="playerParticipationBody">
        <tr><td colspan="4" class="center-cell" style="color:var(--muted);">No participation data yet.</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <!-- Pair Usage -->
  <section class="card pair-usage-card">
    <h2>üéæ Pair Usage</h2>
    <p class="hint">Counts match days for each doubles pairing. Rows highlight in red once a pair reaches three days together.</p>
    <div class="table-container">
      <table class="responsive-table">
        <thead>
        <tr>
          <th>#</th>
          <th>Team</th>
          <th>Pair</th>
          <th>Match Days Together</th>
        </tr>
        </thead>
        <tbody id="pairUsageBody">
        <tr><td colspan="4" class="center-cell" style="color:var(--muted);">No pair data yet.</td></tr>
        </tbody>
      </table>
    </div>
  </section>
</main>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
  /* ==========
     Firebase Setup & Teams
     ========== */
  const firebaseConfig = {
    apiKey: "AIzaSyDbO0eP52i4t3V94bEiDcl7WoKbSrrM9VA",
    authDomain: "koc2-20fb8.firebaseapp.com",
    databaseURL: "https://koc2-20fb8-default-rtdb.firebaseio.com",
    projectId: "koc2-20fb8",
    storageBucket: "koc2-20fb8.firebasestorage.app",
    messagingSenderId: "317734341461",
    appId: "1:317734341461:web:1bcad5a1792fac0e46bddc"
  };

  const firebaseApp = firebase.apps && firebase.apps.length ? firebase.app() : firebase.initializeApp(firebaseConfig);
  const auth = firebaseApp.auth();
  const database = firebaseApp.database();
  const matchesRef = database.ref('season2Matches');

  let authReady = false;
  let authPromise = null;
  let authError = null;

  function ensureAuth(){
    if(authReady) return Promise.resolve();
    if(authPromise) return authPromise;
    authPromise = auth.signInAnonymously()
      .then(() => {
        authReady = true;
        authError = null;
      })
      .catch(err => {
        authReady = false;
        authError = err;
        throw err;
      })
      .finally(() => {
        authPromise = null;
      });
    return authPromise;
  }

  function getSelectedTeamMeta(team){
    const select = team === 1 ? t1 : t2;
    const value = select && select.value ? select.value.trim() : '';
    const data = value ? TEAM_LOOKUP.get(value) || null : null;
    const name = data ? data.name : (value || `Team ${team}`);
    let abbreviation = '';
    if(data && typeof data.abbreviation === 'string' && data.abbreviation.trim()){
      abbreviation = data.abbreviation.trim();
    }
    if(!abbreviation){
      abbreviation = value
        ? value.split(/\s+/).map(word => word.charAt(0).toUpperCase()).join('').slice(0,3) || value.charAt(0).toUpperCase()
        : `T${team}`;
    }
    const roster = data && Array.isArray(data.players) ? data.players.slice() : [];
    return { name, abbreviation, roster };
  }

  function getTeamDisplayName(team){
    return getSelectedTeamMeta(team).name;
  }

  function refreshLineTeamLabelsForRow(row){
    if(!row) return;
    const meta1 = getSelectedTeamMeta(1);
    const meta2 = getSelectedTeamMeta(2);
    row.querySelectorAll('.line-team-label').forEach(label => {
      const team = Number(label.dataset.team);
      if(team === 1){
        label.textContent = meta1.name;
      } else if(team === 2){
        label.textContent = meta2.name;
      }
    });
    row.querySelectorAll('.line-side-avatar').forEach(avatar => {
      const team = Number(avatar.dataset.team);
      const meta = team === 1 ? meta1 : meta2;
      avatar.textContent = meta.abbreviation || String(team);
      avatar.setAttribute('title', meta.name);
    });
    refreshLinePlayersForRow(row);
  }

  function refreshAllLineTeamLabels(){
    Array.from(lineContainer.querySelectorAll('.line-row')).forEach(refreshLineTeamLabelsForRow);
  }

  function inferLineMode(label=''){
    const text = String(label || '').toLowerCase();
    if(text.includes('single')) return 'singles';
    return 'doubles';
  }

  function getLinePlayers(row, team, { visibleOnly=true } = {}){
    if(!row) return [];
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"]`));
    return selects
      .filter(select => {
        if(!visibleOnly) return true;
        const field = select.closest('.player-field');
        return !(field && field.classList.contains('hidden'));
      })
      .map(select => (select.value || '').trim())
      .filter(Boolean);
  }

  function setLinePlayers(row, team, players){
    if(!row) return;
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"]`));
    const list = Array.isArray(players)
      ? players.map(player => typeof player === 'string' ? player : String(player || '')).filter(name => name !== '')
      : [];
    if(mode === 'singles'){
      const target = selects[0];
      if(target){
        target.value = list.length ? list[0] : '';
      }
    } else {
      selects.forEach((select, idx) => {
        if(idx < list.length){
          select.value = list[idx];
        } else {
          select.value = '';
        }
      });
    }
    updateLineupSummary(row, team);
  }

  function enforceUniquePlayers(team){
    const container = document.getElementById('lineContainer');
    if(!container) return;
    const selects = Array.from(container.querySelectorAll(`.player-select[data-team="${team}"]`));
    selects.forEach(select => {
      Array.from(select.options).forEach(option => {
        option.disabled = false;
        option.hidden = false;
      });
    });
  }

  function updateLineupSummary(row, team){
    if(!row) return;
    const summary = row.querySelector(`.line-player-summary[data-team="${team}"]`);
    if(!summary) return;
    const meta = getSelectedTeamMeta(team);
    const players = getLinePlayers(row, team);
    const prefix = meta.abbreviation || meta.name;
    if(players.length){
      summary.textContent = `${prefix} lineup: ${players.join(' / ')}`;
    } else {
      summary.textContent = `${prefix} lineup: ‚Äî`;
    }
  }

  function refreshTeamPlayers(row, team){
    if(!row) return;
    const meta = getSelectedTeamMeta(team);
    const roster = Array.isArray(meta.roster) ? meta.roster : [];
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    const selects = Array.from(row.querySelectorAll(`.player-select[data-team="${team}"]`));
    selects.forEach(select => {
      const slot = Number(select.dataset.slot);
      const previous = select.value || select.dataset.initialValue || '';
      delete select.dataset.initialValue;
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      if(!meta.name || roster.length === 0){
        placeholder.textContent = 'Select team first';
      } else if(mode === 'singles'){
        placeholder.textContent = 'Select player';
      } else {
        placeholder.textContent = `Select player ${slot + 1}`;
      }
      select.appendChild(placeholder);
      roster.forEach(player => {
        const opt = document.createElement('option');
        opt.value = player;
        opt.textContent = player;
        select.appendChild(opt);
      });
      if(previous && roster.includes(previous)){
        select.value = previous;
      } else {
        select.value = '';
      }
      select.disabled = roster.length === 0;
    });
    updateLineupSummary(row, team);
    enforceUniquePlayers(team);
  }

  function refreshLinePlayersForRow(row){
    refreshTeamPlayers(row, 1);
    refreshTeamPlayers(row, 2);
  }

  function applyPlayerSlotMode(row){
    if(!row) return;
    const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
    row.querySelectorAll('.player-field').forEach(field => {
      const slot = Number(field.dataset.slot);
      const label = field.querySelector('.player-slot-label');
      const select = field.querySelector('.player-select');
      if(mode === 'singles'){
        if(slot === 0){
          field.classList.remove('hidden');
          if(label) label.textContent = 'Player';
        } else {
          field.classList.add('hidden');
          if(select) select.value = '';
        }
      } else {
        field.classList.remove('hidden');
        if(label) label.textContent = `Player ${slot + 1}`;
      }
    });
    updateLineupSummary(row, 1);
    updateLineupSummary(row, 2);
    enforceUniquePlayers(1);
    enforceUniquePlayers(2);
  }

  function updateLineTotals(row){
    if(!row) return;
    let partial = false;
    let seenAny = false;
    const setsForTotals = [];

    for(let i=0; i<SET_COUNT; i++){
      const t1Input = row.querySelector(`.set-input[data-team="1"][data-set="${i}"]`);
      const t2Input = row.querySelector(`.set-input[data-team="2"][data-set="${i}"]`);
      const tieWraps = row.querySelectorAll(`.tie-break[data-set="${i}"]`);
      const tieInputs = row.querySelectorAll(`.tie-input[data-set="${i}"]`);
      if(!t1Input || !t2Input){
        tieWraps.forEach(w => w.classList.add('hidden'));
        continue;
      }
      const raw1 = t1Input.value.trim();
      const raw2 = t2Input.value.trim();
      if(raw1 === '' && raw2 === ''){
        tieWraps.forEach(w => w.classList.add('hidden'));
        tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
        continue;
      }
      seenAny = true;
      if(raw1 === '' || raw2 === ''){
        partial = true;
        continue;
      }
      const val1 = Number(raw1);
      const val2 = Number(raw2);
      if(!Number.isInteger(val1) || !Number.isInteger(val2)){
        partial = true;
        continue;
      }
      if(val1 < 0 || val2 < 0 || val1 > MAX_SET_GAMES || val2 > MAX_SET_GAMES){
        partial = true;
        continue;
      }

      const isTieScore = val1 === val2;
      if(isTieScore){
        if(val1 !== TIE_TRIGGER_GAMES){
          partial = true;
          tieWraps.forEach(w => w.classList.add('hidden'));
          tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
          continue;
        }
      } else {
        const winnerScore = Math.max(val1, val2);
        const loserScore = Math.min(val1, val2);
        if(winnerScore !== MAX_SET_GAMES || loserScore > TIE_TRIGGER_GAMES){
          partial = true;
          tieWraps.forEach(w => w.classList.add('hidden'));
          tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
          continue;
        }
      }

      let tieBreak = null;
      if(val1 === val2){
        tieWraps.forEach(w => w.classList.remove('hidden'));
        const tieInput1 = row.querySelector(`.tie-input[data-team="1"][data-set="${i}"]`);
        const tieInput2 = row.querySelector(`.tie-input[data-team="2"][data-set="${i}"]`);
        const tieRaw1 = tieInput1 ? tieInput1.value.trim() : '';
        const tieRaw2 = tieInput2 ? tieInput2.value.trim() : '';
        if(tieRaw1 === '' && tieRaw2 === ''){
          partial = true;
          continue;
        }
        if(tieRaw1 === '' || tieRaw2 === ''){
          partial = true;
          continue;
        }
        const tie1 = Number(tieRaw1);
        const tie2 = Number(tieRaw2);
        if(!Number.isInteger(tie1) || !Number.isInteger(tie2) || tie1 === tie2 || tie1 < 0 || tie2 < 0 || tie1 > 30 || tie2 > 30){
          partial = true;
          continue;
        }
        tieBreak = { team1: tie1, team2: tie2 };
      } else {
        tieWraps.forEach(w => w.classList.add('hidden'));
        tieInputs.forEach(input => { if(input.value !== '') input.value = ''; });
      }

      setsForTotals.push({ team1: val1, team2: val2, tieBreak });
    }

    const totals = computeLineTotalsFromSets(setsForTotals);

    const sides = row.querySelectorAll('.line-side');
    sides.forEach(side => side.classList.remove('winner', 'tied'));

    let mode = 'empty';
    if(partial){
      mode = 'incomplete';
    } else if(setsForTotals.length){
      mode = 'complete';
    } else if(seenAny){
      mode = 'incomplete';
    }

    [1,2].forEach(team => {
      const totalEl = row.querySelector(`.line-total[data-team="${team}"]`);
      if(totalEl){
        if(mode === 'empty'){
          totalEl.textContent = '‚Äî';
        } else {
          const value = team === 1 ? totals.team1 : totals.team2;
          totalEl.textContent = value;
        }
      }
      const statusEl = row.querySelector(`.line-team-status[data-team="${team}"]`);
      if(!statusEl) return;
      if(mode === 'empty'){
        statusEl.textContent = statusEl.dataset.defaultStatus || '';
        statusEl.dataset.state = 'default';
      } else if(mode === 'incomplete'){
        statusEl.textContent = 'INCOMPLETE';
        statusEl.dataset.state = 'incomplete';
      } else {
        statusEl.textContent = 'TIED';
        statusEl.dataset.state = 'tied';
      }
    });

    if(mode === 'complete'){
      const status1 = row.querySelector('.line-team-status[data-team="1"]');
      const status2 = row.querySelector('.line-team-status[data-team="2"]');
      const side1 = row.querySelector('.line-side[data-team="1"]');
      const side2 = row.querySelector('.line-side[data-team="2"]');
      if(totals.team1 > totals.team2){
        if(status1){
          status1.textContent = 'WINNER';
          status1.dataset.state = 'winner';
        }
        if(status2){
          status2.textContent = status2.dataset.defaultStatus || '';
          status2.dataset.state = 'default';
        }
        if(side1) side1.classList.add('winner');
      } else if(totals.team2 > totals.team1){
        if(status2){
          status2.textContent = 'WINNER';
          status2.dataset.state = 'winner';
        }
        if(status1){
          status1.textContent = status1.dataset.defaultStatus || '';
          status1.dataset.state = 'default';
        }
        if(side2) side2.classList.add('winner');
      } else {
        if(status1){
          status1.textContent = 'TIED';
          status1.dataset.state = 'tied';
        }
        if(status2){
          status2.textContent = 'TIED';
          status2.dataset.state = 'tied';
        }
        if(side1) side1.classList.add('tied');
        if(side2) side2.classList.add('tied');
      }
    }
  }

  function formatLineSets(line, { html=false } = {}){
    if(!line || !Array.isArray(line.sets) || !line.sets.length) return '';
    const parts = line.sets.map((set, idx) => {
      const setNumber = Number(set.set);
      const label = Number.isInteger(setNumber) ? setNumber : (idx + 1);
      const t1 = Number(set.team1);
      const t2 = Number(set.team2);
      const safe1 = Number.isFinite(t1) ? t1 : set.team1;
      const safe2 = Number.isFinite(t2) ? t2 : set.team2;
      let text = `S${label} ${safe1}-${safe2}`;
      const tie = extractTieBreak(set);
      if(tie){
        text += ` (TB ${tie.team1}-${tie.team2})`;
      }
      return html ? escapeHTML(text) : text;
    });
    return ` (${parts.join(', ')})`;
  }

  function formatLinePlayers(line, match){
    if(!line || !line.players) return '';
    const list1 = Array.isArray(line.players.team1) ? line.players.team1.filter(Boolean) : [];
    const list2 = Array.isArray(line.players.team2) ? line.players.team2.filter(Boolean) : [];
    if(!list1.length && !list2.length) return '';
    const team1Label = match && match.t1 ? match.t1 : 'Team 1';
    const team2Label = match && match.t2 ? match.t2 : 'Team 2';
    const left = list1.length ? list1.join(' / ') : '‚Äî';
    const right = list2.length ? list2.join(' / ') : '‚Äî';
    return `<div class="line-players"><span>${escapeHTML(team1Label)}: ${escapeHTML(left)}</span><span>${escapeHTML(team2Label)}: ${escapeHTML(right)}</span></div>`;
  }

  function formatLinePlayersText(line, match){
    if(!line || !line.players) return '';
    const list1 = Array.isArray(line.players.team1) ? line.players.team1.filter(Boolean) : [];
    const list2 = Array.isArray(line.players.team2) ? line.players.team2.filter(Boolean) : [];
    if(!list1.length && !list2.length) return '';
    const team1Label = match && match.t1 ? match.t1 : 'Team 1';
    const team2Label = match && match.t2 ? match.t2 : 'Team 2';
    const left = list1.length ? list1.join(' / ') : '‚Äî';
    const right = list2.length ? list2.join(' / ') : '‚Äî';
    return `${team1Label}: ${left} vs ${team2Label}: ${right}`;
  }

  ensureAuth().catch(err => {
    console.error('Failed to authenticate with Firebase', err);
    alert('‚ö†Ô∏è Unable to authenticate with Firebase. Scores will be read-only.');
  });

  async function guardWriteAccess(){
    try {
      await ensureAuth();
      if(!authReady){
        throw authError || new Error('Authentication is required.');
      }
      return true;
    } catch(err){
      console.error('Firebase authentication required before updating scores', err);
      alert('‚ùå Unable to authenticate with Firebase. Scores cannot be updated right now.');
      return false;
    }
  }

  const standingsBody = document.getElementById('standingsBody');
  const historyBody = document.getElementById('historyBody');
  const playerParticipationBody = document.getElementById('playerParticipationBody');
  const pairUsageBody = document.getElementById('pairUsageBody');

  if(historyBody){
    historyBody.addEventListener('click', event => {
      const toggle = event.target.closest('.history-toggle');
      if(!toggle) return;
      const wrapper = toggle.closest('[data-breakdown-wrapper]');
      if(!wrapper) return;
      const panel = wrapper.querySelector('.history-breakdown');
      if(!panel) return;
      const expanded = toggle.getAttribute('aria-expanded') === 'true';
      const next = !expanded;
      toggle.setAttribute('aria-expanded', String(next));
      toggle.textContent = next ? 'Hide breakdown' : 'Show breakdown';
      panel.classList.toggle('open', next);
      panel.hidden = !next;
    });
  }
  standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">Loading standings from Firebase‚Ä¶</td></tr>';
  historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">Loading match history from Firebase‚Ä¶</td></tr>';
  if(playerParticipationBody){
    playerParticipationBody.innerHTML = '<tr><td colspan="4" class="center-cell" style="color:var(--muted);">Loading participation data‚Ä¶</td></tr>';
  }
  if(pairUsageBody){
    pairUsageBody.innerHTML = '<tr><td colspan="4" class="center-cell" style="color:var(--muted);">Loading pair usage‚Ä¶</td></tr>';
  }

  let matches = [];
  let matchesLoaded = false;

  const TOURNAMENT = {
    tournament: 'Tournament Teams',
    description: '9 teams with 7 players each competing for the championship',
    teams: [
      {
        name: 'Rally Royals',
        abbreviation: 'RR',
        captain: 'Yogesh',
        players: [
          'Yogesh',
          'Srinivaasan Arumugam Sampath',
          'Charan Macharla',
          'Kalam Shaik',
          'Sandeep Gengineri',
          'Chandrakant Dharme',
          'Vasu Gandhi'
        ]
      },
      {
        name: "Karna's Crusaders",
        abbreviation: 'KC',
        captain: 'Srikanth',
        players: [
          'Srikanth',
          'Vibhor Sharma',
          'Malla Cheerke',
          'Anshul Goyal',
          'Srinidhi Kulkarni',
          'Lloyd Kumar',
          'Dinkar Bhardwaj'
        ]
      },
      {
        name: 'Spin Kings',
        abbreviation: 'SK',
        captain: 'Uma V',
        players: [
          'Uma V',
          'Madhu',
          'Noufal Mohamed',
          'Kanak Periasamy',
          'Fayaz',
          'KP Krishna',
          'Rajasekhar Mangalampally'
        ]
      },
      {
        name: 'KOC Challengers',
        abbreviation: 'KOCC',
        captain: 'Narayan Prasad',
        players: [
          'Narayan Prasad',
          'Nivas Nazeer',
          'Ravi Sengodan',
          'Damu Palavali',
          'Sarat Edara',
          'Vidya Sagar Reddy',
          'Sudhakar Nallapati'
        ]
      },
      {
        name: 'Rally Squad',
        abbreviation: 'RS',
        captain: 'Manish Jangid',
        players: [
          'Manish Jangid',
          'Srinivas Y',
          'Trinadh Cheepilla',
          'Biju Koshy',
          'Jitender Kumar',
          'Ritesh Kumar',
          'Dinesh Timmareddy'
        ]
      },
      {
        name: 'Agni Aces',
        abbreviation: 'AA',
        captain: 'Vinod Aripaka',
        players: [
          'Vinod Aripaka',
          'Gopi Guru',
          'Venu Servepalli',
          'Nazeer Mohammed',
          'Naveenkumar Mohanram',
          'Nizam Karimudeen',
          'Ratnesh Sinha'
        ]
      },
      {
        name: 'Chill Titans',
        abbreviation: 'CT',
        captain: 'Satish Orugunta',
        players: [
          'Satish Orugunta',
          'Gokul R',
          'Prashanth Tiramareddi',
          'Jaweed',
          'Ram Kantheti',
          'Durga',
          'Hari Mothukuri'
        ]
      },
      {
        name: 'Mega Lions',
        abbreviation: 'ML',
        captain: 'Anil Kunda',
        players: [
          'Anil Kunda',
          'Mirza H',
          'Raj Chejerla',
          'Mohan Koripuri',
          'Venky Dh',
          'Rajasekhar Karru',
          'Nagarjuna Saladi'
        ]
      },
      {
        name: 'Court Conquerors',
        abbreviation: 'CC',
        captain: 'Rajasekhar Chintha',
        players: [
          'Rajasekhar Chintha',
          'Venis V',
          'Jilani Pathan',
          'Bhaskar Boddireddy',
          'Ali Mohamed',
          'Sridhar K',
          'Krishna Vennapusa'
        ]
      }
    ]
  };

  const TEAM_LOOKUP = new Map(TOURNAMENT.teams.map(team => [team.name, team]));
  const TEAMS = TOURNAMENT.teams.map(team => team.name);
  const DEFAULT_LINES = [
    { label: 'Doubles Line 1', type: 'doubles' },
    { label: 'Doubles Line 2', type: 'doubles' },
    { label: 'Doubles Line 3', type: 'doubles' },
    { label: 'Doubles Line 4', type: 'doubles' },
    { label: 'Singles Line 1', type: 'singles' }
  ];
  const SET_COUNT = 3;
  const MAX_SET_GAMES = 4;
  const TIE_TRIGGER_GAMES = Math.max(0, MAX_SET_GAMES - 1);

  const HTML_ESCAPE_LOOKUP = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' };
  const escapeHTML = (value='') => String(value).replace(/[&<>"']/g, ch => HTML_ESCAPE_LOOKUP[ch] || ch);

  function extractTieBreak(entry){
    if(!entry || typeof entry !== 'object') return null;
    const direct = entry.tieBreak ?? entry.tiebreak ?? entry.tb ?? null;
    let tie1;
    let tie2;
    if(direct && typeof direct === 'object'){
      tie1 = Number(direct.team1 ?? direct.t1 ?? direct.a ?? direct.score1 ?? direct.p1);
      tie2 = Number(direct.team2 ?? direct.t2 ?? direct.b ?? direct.score2 ?? direct.p2);
    }
    if(!Number.isInteger(tie1) || !Number.isInteger(tie2)){
      tie1 = Number(entry.tieBreakTeam1 ?? entry.tiebreakTeam1 ?? entry.tie1 ?? entry.tb1 ?? entry.t1tb ?? entry.tbTeam1);
      tie2 = Number(entry.tieBreakTeam2 ?? entry.tiebreakTeam2 ?? entry.tie2 ?? entry.tb2 ?? entry.t2tb ?? entry.tbTeam2);
    }
    if(!Number.isInteger(tie1) || !Number.isInteger(tie2)) return null;
    if(tie1 < 0 || tie2 < 0 || tie1 > 30 || tie2 > 30) return null;
    if(tie1 === tie2) return null;
    return { team1: tie1, team2: tie2 };
  }

  function computeLineTotalsFromSets(sets){
    if(!Array.isArray(sets) || !sets.length) return { team1:0, team2:0, sets1:0, sets2:0 };
    return sets.reduce((totals, set) => {
      const games1 = Number(set.team1);
      const games2 = Number(set.team2);
      if(Number.isInteger(games1)) totals.team1 += games1;
      if(Number.isInteger(games2)) totals.team2 += games2;
      if(Number.isInteger(games1) && Number.isInteger(games2)){
        if(games1 > games2){
          totals.sets1 += 1;
        } else if(games2 > games1){
          totals.sets2 += 1;
        } else {
          const tie = extractTieBreak(set) ?? (set.tieBreak ?? null);
          if(tie && Number.isInteger(tie.team1) && Number.isInteger(tie.team2) && tie.team1 !== tie.team2){
            if(tie.team1 > tie.team2){
              totals.team1 += 1;
              totals.sets1 += 1;
            } else {
              totals.team2 += 1;
              totals.sets2 += 1;
            }
          }
        }
      }
      return totals;
    }, { team1:0, team2:0, sets1:0, sets2:0 });
  }

  function sanitizeSetList(list){
    if(!Array.isArray(list)) return [];
    const clean = [];
    list.forEach((entry, idx) => {
      if(!entry) return;
      const t1 = Number(entry.team1 ?? entry.t1 ?? entry.a ?? entry.g1 ?? entry.score1);
      const t2 = Number(entry.team2 ?? entry.t2 ?? entry.b ?? entry.g2 ?? entry.score2);
      if(!Number.isInteger(t1) || !Number.isInteger(t2)) return;
      if(t1 < 0 || t2 < 0 || t1 > MAX_SET_GAMES || t2 > MAX_SET_GAMES) return;
      const isTie = t1 === t2;
      if(isTie){
        if(t1 !== TIE_TRIGGER_GAMES) return;
      } else {
        const winnerScore = Math.max(t1, t2);
        const loserScore = Math.min(t1, t2);
        if(winnerScore !== MAX_SET_GAMES) return;
        if(loserScore > TIE_TRIGGER_GAMES) return;
      }
      let setNumber = Number(entry.set ?? entry.index ?? entry.order ?? entry.num ?? (idx + 1));
      if(!Number.isInteger(setNumber) || setNumber < 1 || setNumber > 5){
        setNumber = clean.length + 1;
      }
      const tieBreak = t1 === t2 ? extractTieBreak(entry) : null;
      const payload = { set:setNumber, team1:t1, team2:t2 };
      if(tieBreak) payload.tieBreak = tieBreak;
      clean.push(payload);
    });
    clean.sort((a,b)=>a.set - b.set);
    return clean;
  }

  function sanitizePlayerList(value){
    if(!value) return [];
    let list = [];
    if(Array.isArray(value)){
      list = value;
    } else if(typeof value === 'string'){
      list = value.split(/[,/&]|\band\b/i);
    } else if(typeof value === 'object'){
      list = Object.values(value);
    }
    return list
      .map(entry => typeof entry === 'string' ? entry.trim() : '')
      .filter(Boolean)
      .slice(0, 2);
  }

  function sanitizeLineType(rawType, label='', team1Players=[], team2Players=[]){
    const normalized = typeof rawType === 'string' ? rawType.trim().toLowerCase() : '';
    if(normalized.startsWith('single')) return 'singles';
    if(normalized.startsWith('double')) return 'doubles';
    const maxPlayers = Math.max(team1Players.length, team2Players.length);
    if(maxPlayers <= 1 && maxPlayers > 0) return 'singles';
    const labelText = String(label || '').toLowerCase();
    if(labelText.includes('single')) return 'singles';
    if(labelText.includes('double')) return 'doubles';
    return 'doubles';
  }

  function sanitizeLines(list){
    if(!Array.isArray(list)) return [];
    const clean = [];
    list.forEach((entry) => {
      if(!entry) return;
      const label = typeof entry.label === 'string' ? entry.label.trim() : '';
      const sets = sanitizeSetList(entry.sets ?? entry.setScores ?? entry.setList);
      let g1 = Number(entry.g1);
      let g2 = Number(entry.g2);
      let totals = null;
      if(sets.length){
        totals = computeLineTotalsFromSets(sets);
        g1 = totals.team1;
        g2 = totals.team2;
      }
      if(!Number.isInteger(g1) || !Number.isInteger(g2)) return;
      if(g1 < 0 || g2 < 0 || g1 > 90 || g2 > 90) return;
      const playersSource = (entry.players && typeof entry.players === 'object') ? entry.players : {};
      const team1Players = sanitizePlayerList(playersSource.team1 ?? entry.team1Players ?? entry.team1Lineup ?? entry.p1 ?? entry.lineup1);
      const team2Players = sanitizePlayerList(playersSource.team2 ?? entry.team2Players ?? entry.team2Lineup ?? entry.p2 ?? entry.lineup2);
      const lineType = sanitizeLineType(entry.type ?? entry.mode ?? entry.format, label, team1Players, team2Players);
      const cleanEntry = { label: label || `Court ${clean.length + 1}`, g1, g2, type: lineType };
      if(sets.length){
        cleanEntry.sets = sets.map(set => {
          const payload = { set:set.set, team1:set.team1, team2:set.team2 };
          if(set.tieBreak) payload.tieBreak = { team1:set.tieBreak.team1, team2:set.tieBreak.team2 };
          return payload;
        });
      }
      const totalsForSets = totals || { team1:g1, team2:g2, sets1:0, sets2:0 };
      let setWins = { team1: totalsForSets.sets1, team2: totalsForSets.sets2 };
      if(!sets.length){
        const rawSetWins1 = Number((entry.setWins && entry.setWins.team1) ?? entry.setWinsTeam1 ?? entry.s1 ?? entry.setsWonTeam1 ?? entry.sets1);
        const rawSetWins2 = Number((entry.setWins && entry.setWins.team2) ?? entry.setWinsTeam2 ?? entry.s2 ?? entry.setsWonTeam2 ?? entry.sets2);
        if(Number.isInteger(rawSetWins1) && Number.isInteger(rawSetWins2)){
          setWins = { team1: rawSetWins1, team2: rawSetWins2 };
        }
      }
      cleanEntry.setWins = setWins;
      if(team1Players.length || team2Players.length){
        cleanEntry.players = {};
        if(team1Players.length) cleanEntry.players.team1 = team1Players;
        if(team2Players.length) cleanEntry.players.team2 = team2Players;
      }
      clean.push(cleanEntry);
    });
    return clean;
  }

  function sanitizeDreambreaker(db){
    if(!db) return null;
    const g1 = Number(db.g1 ?? db.team1 ?? db.t1 ?? db.points1 ?? db.p1);
    const g2 = Number(db.g2 ?? db.team2 ?? db.t2 ?? db.points2 ?? db.p2);
    if(!Number.isInteger(g1) || !Number.isInteger(g2)) return null;
    if(g1 < 0 || g2 < 0 || g1 > 40 || g2 > 40) return null;
    if(g1 === 0 && g2 === 0) return null;
    return { g1, g2 };
  }

  function deriveLineSetWins(line){
    if(!line) return { team1:0, team2:0 };
    const raw = line.setWins && typeof line.setWins === 'object' ? line.setWins : {};
    let team1 = Number(raw.team1 ?? raw.t1 ?? raw.a ?? raw.sets1 ?? raw.w1);
    let team2 = Number(raw.team2 ?? raw.t2 ?? raw.b ?? raw.sets2 ?? raw.w2);
    if(!Number.isInteger(team1) || !Number.isInteger(team2)){
      const totals = computeLineTotalsFromSets(line.sets || []);
      team1 = totals.sets1;
      team2 = totals.sets2;
    }
    team1 = Number.isInteger(team1) && team1 >= 0 ? team1 : 0;
    team2 = Number.isInteger(team2) && team2 >= 0 ? team2 : 0;
    return { team1, team2 };
  }

  function upgradeMatch(m){
    if(!m || !m.t1 || !m.t2) return null;
    const lines = sanitizeLines(m.lines);
    let g1 = Number(m.g1);
    let g2 = Number(m.g2);

    if(!Number.isFinite(g1) || !Number.isFinite(g2)){
      if(lines.length){
        g1 = lines.reduce((sum,row)=>sum + (Number(row.g1) || 0), 0);
        g2 = lines.reduce((sum,row)=>sum + (Number(row.g2) || 0), 0);
      } else if(typeof m.s1 !== 'undefined' && typeof m.s2 !== 'undefined'){
        const fallbackG1 = Number(m.s1);
        const fallbackG2 = Number(m.s2);
        if(Number.isFinite(fallbackG1) && Number.isFinite(fallbackG2) && (Math.abs(fallbackG1) > 6 || Math.abs(fallbackG2) > 6)){
          g1 = fallbackG1;
          g2 = fallbackG2;
        }
      }
    }

    if(!Number.isFinite(g1) || !Number.isFinite(g2)) return null;
    g1 = Math.round(g1);
    g2 = Math.round(g2);
    if(g1 < 0 || g2 < 0 || g1 > 120 || g2 > 120) return null;

    if(lines.length){
      const sum1 = lines.reduce((sum,row)=>sum + (Number(row.g1) || 0),0);
      const sum2 = lines.reduce((sum,row)=>sum + (Number(row.g2) || 0),0);
      g1 = sum1;
      g2 = sum2;
    }

    let sets1 = Number(m.s1);
    let sets2 = Number(m.s2);
    if(!Number.isInteger(sets1) || !Number.isInteger(sets2)){
      const setsObj = m.sets && typeof m.sets === 'object' ? m.sets : null;
      if(setsObj){
        const raw1 = Number(setsObj.team1 ?? setsObj.t1 ?? setsObj.a ?? setsObj.w1);
        const raw2 = Number(setsObj.team2 ?? setsObj.t2 ?? setsObj.b ?? setsObj.w2);
        if(Number.isInteger(raw1) && Number.isInteger(raw2)){
          sets1 = raw1;
          sets2 = raw2;
        }
      }
    }
    if(!Number.isInteger(sets1) || !Number.isInteger(sets2)){
      if(lines.length){
        const totalSets = lines.reduce((acc,line)=>{
          const wins = deriveLineSetWins(line);
          acc.team1 += wins.team1;
          acc.team2 += wins.team2;
          return acc;
        }, { team1:0, team2:0 });
        sets1 = totalSets.team1;
        sets2 = totalSets.team2;
      }
    }
    sets1 = Number.isInteger(sets1) && sets1 >= 0 ? sets1 : 0;
    sets2 = Number.isInteger(sets2) && sets2 >= 0 ? sets2 : 0;

    const dreambreaker = sanitizeDreambreaker(m.dreambreaker);
    const derivedWin = g1 === g2 ? null : (g1 > g2 ? m.t1 : m.t2);
    let win = (m.win === m.t1 || m.win === m.t2) ? m.win : derivedWin;
    if(!win && dreambreaker && dreambreaker.g1 !== dreambreaker.g2){
      win = dreambreaker.g1 > dreambreaker.g2 ? m.t1 : m.t2;
    }

    const tsNumber = Number(m.ts);
    const ts = Number.isFinite(tsNumber) ? tsNumber : Date.now();
    const upgraded = { t1:m.t1, t2:m.t2, g1, g2, win, ts, s1: sets1, s2: sets2 };
    if(lines.length) upgraded.lines = lines;
    if(dreambreaker && dreambreaker.g1 !== dreambreaker.g2) upgraded.dreambreaker = dreambreaker;
    return upgraded;
  }

  function handleSnapshot(snapshot){
    const data = snapshot.val();
    const list = [];
    if(data && typeof data === 'object'){
      for(const [id, entry] of Object.entries(data)){
        const upgraded = upgradeMatch(entry);
        if(upgraded){
          upgraded.id = id;
          list.push(upgraded);
        }
      }
    }
    matches = list.sort((a,b)=>b.ts - a.ts);
    matchesLoaded = true;
    renderAll();
  }

  async function handleMatchesError(error){
    console.error('Failed to load matches from Firebase', error);
    if(error && error.code === 'PERMISSION_DENIED'){
      try {
        await ensureAuth();
        if(authReady){
          subscribeToMatches();
          return;
        }
      } catch(authErr){
        console.error('Firebase authentication attempt failed while retrying listener', authErr);
      }
    }
    matches = [];
    matchesLoaded = true;
    renderAll();
    alert('‚ùå Failed to load matches from server. Please try again later.');
  }

  function subscribeToMatches(){
    matchesRef.off();
    matchesRef.on('value', handleSnapshot, handleMatchesError);
  }

  subscribeToMatches();

  /* ==========
     UI: Nav (mobile)
     ========== */
  const menuBtn = document.getElementById('menuBtn');
  const siteNav = document.getElementById('siteNav');
  menuBtn.addEventListener('click', () => {
    const open = siteNav.classList.toggle('open');
    menuBtn.setAttribute('aria-expanded', String(open));
  });

  /* ==========
     Access Lock/Unlock
     ========== */
  const scoringForm = document.getElementById('scoringForm');
  document.getElementById('unlockBtn').addEventListener('click', () => {
    const code = (document.getElementById('accessCode').value || '').trim();
    if(code === 'KOCPO#2'){
      scoringForm.classList.remove('hidden');
      document.getElementById('accessCode').value = '';
      alert('‚úÖ Scoring unlocked');
    } else {
      alert('‚ùå Invalid code');
    }
  });
  document.getElementById('lockBtn').addEventListener('click', () => {
    scoringForm.classList.add('hidden');
    alert('üîí Scoring locked');
  });

  /* ==========
     Populate selects
     ========== */
  const t1 = document.getElementById('team1Name');
  const t2 = document.getElementById('team2Name');
  function fillTeams(){
    const opts = ['<option value="">Select Team</option>', ...TEAMS.map(n=>`<option value="${n}">${n}</option>`)].join('');
    t1.innerHTML = opts.replace('Select Team','Select Team 1');
    t2.innerHTML = opts.replace('Select Team','Select Team 2');
  }
  fillTeams();
  t1.addEventListener('change', () => refreshAllLineTeamLabels());
  t2.addEventListener('change', () => refreshAllLineTeamLabels());

  /* ==========
     Court editor helpers
     ========== */
  const lineContainer = document.getElementById('lineContainer');
  const addLineBtn = document.getElementById('addLineBtn');
  const resetLinesBtn = document.getElementById('resetLinesBtn');
  const crossCourtBtn = document.getElementById('crossCourtBtn');
  const dreambreakerToggle = document.getElementById('dreambreakerToggle');
  const dreambreakerFields = document.getElementById('dreambreakerFields');
  const dreambreakerTeam1 = document.getElementById('dreambreakerTeam1');
  const dreambreakerTeam2 = document.getElementById('dreambreakerTeam2');

  function makeLineRow(label='', sets=[], config={}){
    const row = document.createElement('div');
    row.className = 'line-row';

    const header = document.createElement('div');
    header.className = 'line-row-header';

    const labelInput = document.createElement('input');
    labelInput.type = 'text';
    labelInput.className = 'line-label';
    labelInput.placeholder = 'Court or matchup (e.g. Line 1 Singles)';
    labelInput.value = label;

    const typeSelect = document.createElement('select');
    typeSelect.className = 'line-type-select';
    typeSelect.innerHTML = `
      <option value="doubles">Doubles</option>
      <option value="singles">Singles</option>
    `;

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'line-remove';
    removeBtn.title = 'Remove court';
    removeBtn.textContent = '‚úï';
    removeBtn.addEventListener('click', () => {
      row.remove();
      if(!lineContainer.children.length){
        addDefaultLines();
      } else {
        refreshAllLineTeamLabels();
      }
      enforceUniquePlayers(1);
      enforceUniquePlayers(2);
    });

    header.append(labelInput, typeSelect, removeBtn);

    const scorecard = document.createElement('div');
    scorecard.className = 'line-scorecard';

    const setLabels = document.createElement('div');
    setLabels.className = 'line-set-labels';
    setLabels.innerHTML = `<span>Matchup</span>${Array.from({ length: SET_COUNT }, (_, i) => `<span>Set ${i + 1}</span>`).join('')}<span>Total</span>`;
    scorecard.appendChild(setLabels);

    const normalizedSets = new Map();
    if(Array.isArray(sets)){
      sets.forEach((set, idx) => {
        const rawIndex = Number(set.set ?? set.index ?? set.order ?? (idx + 1));
        if(!Number.isInteger(rawIndex) || rawIndex < 1 || rawIndex > SET_COUNT) return;
        const base = {
          team1: set.team1 ?? set.t1 ?? set.score1,
          team2: set.team2 ?? set.t2 ?? set.score2
        };
        const tieBreak = extractTieBreak(set);
        if(tieBreak){
          base.tieBreak = tieBreak;
        }
        normalizedSets.set(rawIndex - 1, base);
      });
    }

    const playersConfig = config && typeof config === 'object' && config.players ? config.players : {};
    const presetPlayers = {
      1: Array.isArray(playersConfig.team1) ? playersConfig.team1.slice(0,2) : [],
      2: Array.isArray(playersConfig.team2) ? playersConfig.team2.slice(0,2) : []
    };

    const initialModeRaw = config && typeof config.type === 'string' ? config.type : inferLineMode(label);
    const initialMode = initialModeRaw === 'singles' ? 'singles' : 'doubles';
    row.dataset.mode = initialMode;
    typeSelect.value = initialMode;
    typeSelect.addEventListener('change', () => {
      row.dataset.mode = typeSelect.value === 'singles' ? 'singles' : 'doubles';
      applyPlayerSlotMode(row);
      refreshLinePlayersForRow(row);
      updateLineTotals(row);
    });

    const buildSide = (team) => {
      const side = document.createElement('div');
      side.className = 'line-side';
      side.dataset.team = String(team);

      const info = document.createElement('div');
      info.className = 'line-side-info';

      const avatar = document.createElement('div');
      avatar.className = 'line-side-avatar';
      avatar.dataset.team = String(team);
      avatar.textContent = team;

      const infoText = document.createElement('div');

      const name = document.createElement('div');
      name.className = 'line-team-label';
      name.dataset.team = String(team);
      name.textContent = team === 1 ? 'Team 1' : 'Team 2';

      const status = document.createElement('div');
      status.className = 'line-team-status';
      status.dataset.team = String(team);
      status.dataset.defaultStatus = 'LINEUP';
      status.textContent = status.dataset.defaultStatus;

      infoText.append(name, status);
      info.append(avatar, infoText);

      const playerPicker = document.createElement('div');
      playerPicker.className = 'player-picker';
      playerPicker.dataset.team = String(team);

      const savedList = presetPlayers[team];
      for(let i = 0; i < 2; i++){
        const field = document.createElement('label');
        field.className = 'player-field';
        field.dataset.team = String(team);
        field.dataset.slot = String(i);

        const slotLabel = document.createElement('span');
        slotLabel.className = 'player-slot-label';
        slotLabel.textContent = `Player ${i + 1}`;

        const playerSelect = document.createElement('select');
        playerSelect.className = 'player-select';
        playerSelect.dataset.team = String(team);
        playerSelect.dataset.slot = String(i);
        playerSelect.disabled = true;
        if(savedList && savedList[i]){
          playerSelect.dataset.initialValue = savedList[i];
        }
        playerSelect.addEventListener('change', () => {
          updateLineupSummary(row, team);
          enforceUniquePlayers(team);
        });

        field.append(slotLabel, playerSelect);
        playerPicker.appendChild(field);
      }

      const playerSummary = document.createElement('div');
      playerSummary.className = 'line-player-summary';
      playerSummary.dataset.team = String(team);
      playerSummary.textContent = 'Lineup: ‚Äî';

      const setInputs = document.createElement('div');
      setInputs.className = 'line-set-inputs';

      for(let i = 0; i < SET_COUNT; i++){
        const field = document.createElement('div');
        field.className = 'set-field';
        field.dataset.set = String(i);

        const gamesInput = document.createElement('input');
        gamesInput.type = 'number';
        gamesInput.inputMode = 'numeric';
        gamesInput.className = 'set-input';
        gamesInput.min = '0';
        gamesInput.max = String(MAX_SET_GAMES);
        gamesInput.step = '1';
        gamesInput.dataset.team = String(team);
        gamesInput.dataset.set = String(i);
        gamesInput.setAttribute('aria-label', `${team === 1 ? 'Team 1' : 'Team 2'} set ${i + 1} games`);

        const stored = normalizedSets.get(i);
        if(stored){
          const value = team === 1 ? stored.team1 : stored.team2;
          if(Number.isInteger(Number(value))){
            gamesInput.value = Number(value);
          }
        }

        gamesInput.addEventListener('input', () => updateLineTotals(row));
        field.appendChild(gamesInput);

        const tieWrap = document.createElement('div');
        tieWrap.className = 'tie-break hidden';
        tieWrap.dataset.set = String(i);

        const tieLabel = document.createElement('span');
        tieLabel.className = 'tie-label';
        tieLabel.textContent = 'TB';

        const tieInput = document.createElement('input');
        tieInput.type = 'number';
        tieInput.inputMode = 'numeric';
        tieInput.className = 'tie-input';
        tieInput.min = '0';
        tieInput.max = '30';
        tieInput.step = '1';
        tieInput.dataset.team = String(team);
        tieInput.dataset.set = String(i);
        tieInput.setAttribute('aria-label', `${team === 1 ? 'Team 1' : 'Team 2'} set ${i + 1} tiebreak points`);

        if(stored && stored.tieBreak){
          const tieVal = team === 1 ? stored.tieBreak.team1 : stored.tieBreak.team2;
          if(Number.isInteger(Number(tieVal))){
            tieInput.value = Number(tieVal);
            tieWrap.classList.remove('hidden');
          }
        }

        tieInput.addEventListener('input', () => updateLineTotals(row));

        tieWrap.append(tieLabel, tieInput);
        field.appendChild(tieWrap);
        setInputs.appendChild(field);
      }

      const total = document.createElement('div');
      total.className = 'line-total';
      total.dataset.team = String(team);
      total.textContent = '‚Äî';

      side.append(info, playerPicker, playerSummary, setInputs, total);
      return side;
    };

    scorecard.appendChild(buildSide(1));
    scorecard.appendChild(buildSide(2));

    row.append(header, scorecard);

    applyPlayerSlotMode(row);
    refreshLineTeamLabelsForRow(row);
    updateLineTotals(row);

    return row;
  }

  function addLine(label=''){
    const cleanLabel = label || `Court ${lineContainer.children.length + 1}`;
    const type = inferLineMode(cleanLabel);
    const row = makeLineRow(cleanLabel, [], { type });
    lineContainer.appendChild(row);
    enforceUniquePlayers(1);
    enforceUniquePlayers(2);
  }

  function addDefaultLines(){
    lineContainer.innerHTML = '';
    DEFAULT_LINES.forEach(entry => {
      const item = typeof entry === 'string' ? { label: entry } : entry;
      const row = makeLineRow(item.label, [], { type: item.type || inferLineMode(item.label) });
      lineContainer.appendChild(row);
    });
    refreshAllLineTeamLabels();
    enforceUniquePlayers(1);
    enforceUniquePlayers(2);
  }

  function clearLineScores(){
    Array.from(lineContainer.querySelectorAll('.line-row')).forEach(row => {
      row.querySelectorAll('.set-input').forEach(input => { input.value = ''; });
      row.querySelectorAll('.tie-input').forEach(input => { input.value = ''; });
      row.querySelectorAll('.player-select').forEach(select => { select.value = ''; });
      updateLineupSummary(row, 1);
      updateLineupSummary(row, 2);
      updateLineTotals(row);
    });
    enforceUniquePlayers(1);
    enforceUniquePlayers(2);
  }

  addDefaultLines();

  addLineBtn.addEventListener('click', () => {
    const idx = lineContainer.children.length + 1;
    const row = makeLineRow(`Court ${idx}`);
    lineContainer.appendChild(row);
  });
  resetLinesBtn.addEventListener('click', () => {
    addDefaultLines();
  });

  if(crossCourtBtn){
    crossCourtBtn.addEventListener('click', () => {
      const rows = Array.from(lineContainer.querySelectorAll('.line-row'));
      const doublesRows = rows.filter(row => (row.dataset.mode === 'singles' ? 'singles' : 'doubles') === 'doubles');
      if(doublesRows.length < 4){
        alert('‚ö†Ô∏è Need at least four doubles courts to fill cross matches.');
        return;
      }

      const [court1, court2, court3, court4] = doublesRows;
      const court1Team1 = getLinePlayers(court1, 1);
      const court1Team2 = getLinePlayers(court1, 2);
      const court2Team1 = getLinePlayers(court2, 1);
      const court2Team2 = getLinePlayers(court2, 2);

      if(court1Team1.length !== 2 || court1Team2.length !== 2 || court2Team1.length !== 2 || court2Team2.length !== 2){
        alert('‚ö†Ô∏è Complete the pair selections on the first two doubles courts before auto-filling.');
        return;
      }

      setLinePlayers(court3, 1, court1Team1);
      setLinePlayers(court3, 2, court2Team2);
      setLinePlayers(court4, 1, court2Team1);
      setLinePlayers(court4, 2, court1Team2);

      enforceUniquePlayers(1);
      enforceUniquePlayers(2);

      alert('‚úÖ Cross matches filled. Verify the pairings before entering scores.');
    });
  }

  dreambreakerToggle.addEventListener('change', () => {
    const on = dreambreakerToggle.checked;
    dreambreakerFields.classList.toggle('hidden', !on);
    if(!on){
      dreambreakerTeam1.value = '';
      dreambreakerTeam2.value = '';
    }
  });

  function collectCourtData(){
    const rows = Array.from(lineContainer.querySelectorAll('.line-row'));
    const lines = [];
    let total1 = 0, total2 = 0;
    let totalSets1 = 0, totalSets2 = 0;
    for(let i=0; i<rows.length; i++){
      const row = rows[i];
      const labelInput = row.querySelector('.line-label');
      const label = (labelInput && labelInput.value ? labelInput.value : '').trim() || `Court ${i+1}`;
      const mode = row.dataset.mode === 'singles' ? 'singles' : 'doubles';
      const sets = [];
      for(let s=0; s<SET_COUNT; s++){
        const input1 = row.querySelector(`.set-input[data-team="1"][data-set="${s}"]`);
        const input2 = row.querySelector(`.set-input[data-team="2"][data-set="${s}"]`);
        if(!input1 || !input2) continue;
        const raw1 = input1.value.trim();
        const raw2 = input2.value.trim();
        if(raw1 === '' && raw2 === '') continue;
        if(raw1 === '' || raw2 === ''){
          return { ok:false, msg:`Complete both scores for Set ${s+1} on ${label}.` };
        }
        const val1 = Number(raw1);
        const val2 = Number(raw2);
        if(!Number.isInteger(val1) || !Number.isInteger(val2)){
          return { ok:false, msg:`Set ${s+1} on ${label} must use whole numbers.` };
        }
        if(val1 < 0 || val2 < 0){
          return { ok:false, msg:`Set ${s+1} on ${label} cannot be negative.` };
        }
        if(val1 > MAX_SET_GAMES || val2 > MAX_SET_GAMES){
          return { ok:false, msg:`Set ${s+1} on ${label} is played to ${MAX_SET_GAMES} games.` };
        }
        if(val1 !== val2){
          const winnerScore = Math.max(val1, val2);
          const loserScore = Math.min(val1, val2);
          if(winnerScore !== MAX_SET_GAMES){
            return { ok:false, msg:`Set ${s+1} on ${label} must be won with ${MAX_SET_GAMES} games.` };
          }
          if(loserScore > TIE_TRIGGER_GAMES){
            return { ok:false, msg:`Set ${s+1} on ${label} cannot give the trailing team more than ${TIE_TRIGGER_GAMES} games.` };
          }
        } else {
          if(val1 !== TIE_TRIGGER_GAMES){
            return { ok:false, msg:`Set ${s+1} on ${label} should be ${TIE_TRIGGER_GAMES}-${TIE_TRIGGER_GAMES} before a tiebreak.` };
          }
        }
        const entry = { set: s + 1, team1: val1, team2: val2 };
        if(val1 === val2){
          const tieInput1 = row.querySelector(`.tie-input[data-team="1"][data-set="${s}"]`);
          const tieInput2 = row.querySelector(`.tie-input[data-team="2"][data-set="${s}"]`);
          const tieRaw1 = tieInput1 ? tieInput1.value.trim() : '';
          const tieRaw2 = tieInput2 ? tieInput2.value.trim() : '';
          if(tieRaw1 === '' || tieRaw2 === ''){
            return { ok:false, msg:`Enter tiebreak points for Set ${s+1} on ${label}.` };
          }
          const tie1 = Number(tieRaw1);
          const tie2 = Number(tieRaw2);
          if(!Number.isInteger(tie1) || !Number.isInteger(tie2)){
            return { ok:false, msg:`Tiebreak on Set ${s+1} for ${label} must use whole numbers.` };
          }
          if(tie1 < 0 || tie2 < 0){
            return { ok:false, msg:`Tiebreak on Set ${s+1} for ${label} cannot be negative.` };
          }
          if(tie1 > 30 || tie2 > 30){
            return { ok:false, msg:`Tiebreak on Set ${s+1} for ${label} looks too high.` };
          }
          if(tie1 === tie2){
            return { ok:false, msg:`Tiebreak on Set ${s+1} for ${label} needs a winner.` };
          }
          entry.tieBreak = { team1: tie1, team2: tie2 };
        }
        sets.push(entry);
      }
      if(sets.length === 0) continue;
      const totals = computeLineTotalsFromSets(sets);
      const team1Players = getLinePlayers(row, 1);
      const team2Players = getLinePlayers(row, 2);
      const meta1 = getSelectedTeamMeta(1);
      const meta2 = getSelectedTeamMeta(2);
      if(mode === 'singles'){
        if(team1Players.length !== 1){
          return { ok:false, msg:`Select a singles player for ${meta1.name} on ${label}.` };
        }
        if(team2Players.length !== 1){
          return { ok:false, msg:`Select a singles player for ${meta2.name} on ${label}.` };
        }
      } else {
        if(team1Players.length !== 2){
          return { ok:false, msg:`Select two doubles players for ${meta1.name} on ${label}.` };
        }
        if(new Set(team1Players).size !== team1Players.length){
          return { ok:false, msg:`${meta1.name} has duplicate players listed on ${label}.` };
        }
        if(team2Players.length !== 2){
          return { ok:false, msg:`Select two doubles players for ${meta2.name} on ${label}.` };
        }
        if(new Set(team2Players).size !== team2Players.length){
          return { ok:false, msg:`${meta2.name} has duplicate players listed on ${label}.` };
        }
      }
      lines.push({
        label,
        g1: totals.team1,
        g2: totals.team2,
        sets,
        type: mode,
        setWins: { team1: totals.sets1, team2: totals.sets2 },
        players: { team1: team1Players, team2: team2Players }
      });
      total1 += totals.team1;
      total2 += totals.team2;
      totalSets1 += totals.sets1;
      totalSets2 += totals.sets2;
    }
    if(lines.length === 0){
      return { ok:false, msg:'Enter at least one set score.' };
    }
    return { ok:true, lines, total1, total2, sets1: totalSets1, sets2: totalSets2 };
  }

  function collectDreambreaker(){
    if(!dreambreakerToggle.checked) return { ok:true, dreambreaker:null };
    const a = dreambreakerTeam1.value.trim();
    const b = dreambreakerTeam2.value.trim();
    if(a === '' || b === ''){
      return { ok:false, msg:'Enter dreambreaker points for both teams.' };
    }
    const g1 = Number(a), g2 = Number(b);
    if(!Number.isInteger(g1) || !Number.isInteger(g2)){
      return { ok:false, msg:'Dreambreaker points must be whole numbers.' };
    }
    if(g1 < 0 || g2 < 0){
      return { ok:false, msg:'Dreambreaker points cannot be negative.' };
    }
    if(g1 === g2){
      return { ok:false, msg:'Dreambreaker cannot end in a tie.' };
    }
    if(g1 > 30 || g2 > 30){
      return { ok:false, msg:'Dreambreaker points look too high.' };
    }
    return { ok:true, dreambreaker:{ g1, g2 } };
  }

  /* ==========
     Derive standings from history
     ========== */
  function computeMatchSetTotals(match){
    if(!match) return { team1:0, team2:0 };
    let s1 = Number(match.s1);
    let s2 = Number(match.s2);
    if(!Number.isInteger(s1) || !Number.isInteger(s2)){
      const setsObj = match.sets && typeof match.sets === 'object' ? match.sets : null;
      if(setsObj){
        const raw1 = Number(setsObj.team1 ?? setsObj.t1 ?? setsObj.a ?? setsObj.w1);
        const raw2 = Number(setsObj.team2 ?? setsObj.t2 ?? setsObj.b ?? setsObj.w2);
        if(Number.isInteger(raw1) && Number.isInteger(raw2)){
          s1 = raw1;
          s2 = raw2;
        }
      }
    }
    if(!Number.isInteger(s1) || !Number.isInteger(s2)){
      if(Array.isArray(match.lines)){
        const totals = match.lines.reduce((acc,line)=>{
          const wins = deriveLineSetWins(line);
          acc.team1 += wins.team1;
          acc.team2 += wins.team2;
          return acc;
        }, { team1:0, team2:0 });
        s1 = totals.team1;
        s2 = totals.team2;
      }
    }
    s1 = Number.isInteger(s1) && s1 >= 0 ? s1 : 0;
    s2 = Number.isInteger(s2) && s2 >= 0 ? s2 : 0;
    return { team1:s1, team2:s2 };
  }

  function computeStandings(){
    const stats = {};
    TEAMS.forEach(n => stats[n] = {
      team:n,
      matches:0,
      wins:0,
      losses:0,
      setsFor:0,
      setsAgainst:0,
      gamesFor:0,
      gamesAgainst:0,
      points:0
    });
    for(const m of matches){
      if(!stats[m.t1] || !stats[m.t2]) continue;
      // increment matches
      stats[m.t1].matches++; stats[m.t2].matches++;
      // games
      stats[m.t1].gamesFor += m.g1; stats[m.t1].gamesAgainst += m.g2;
      stats[m.t2].gamesFor += m.g2; stats[m.t2].gamesAgainst += m.g1;
      const setTotals = computeMatchSetTotals(m);
      stats[m.t1].setsFor += setTotals.team1; stats[m.t1].setsAgainst += setTotals.team2;
      stats[m.t2].setsFor += setTotals.team2; stats[m.t2].setsAgainst += setTotals.team1;
      if(m.win === m.t1){
        stats[m.t1].wins++; stats[m.t2].losses++;
        stats[m.t1].points++;
      } else if(m.win === m.t2){
        stats[m.t2].wins++; stats[m.t1].losses++;
        stats[m.t2].points++;
      }
    }
    Object.values(stats).forEach(s => {
      s.setDiff = s.setsFor - s.setsAgainst;
      s.gameDiff = s.gamesFor - s.gamesAgainst;
    });
    // sort: Match points ‚Üí Set differential ‚Üí Sets for ‚Üí Game differential ‚Üí Games for ‚Üí Name
    const arr = Object.values(stats)
      .sort((a,b)=>
        (b.points - a.points) ||
        (b.setDiff - a.setDiff) ||
        (b.setsFor - a.setsFor) ||
        (b.gameDiff - a.gameDiff) ||
        (b.gamesFor - a.gamesFor) ||
        a.team.localeCompare(b.team)
      );
    return arr;
  }

  function renderStandings(){
    if(!matchesLoaded){
      standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">Loading standings from Firebase‚Ä¶</td></tr>';
      return;
    }

    const rows = computeStandings();

    if(matches.length === 0){
      standingsBody.innerHTML = '<tr><td colspan="12" class="center-cell" style="color:var(--muted);">No results yet. Add a match to see standings.</td></tr>';
      return;
    }

    standingsBody.innerHTML = rows.map((r,i)=>`
      <tr class="${i<4?'qualified':''}">
        <td class="rank-cell" data-label="Rank">${i+1}</td>
        <td class="team-cell" data-label="Team">${r.team}</td>
        <td class="center-cell" data-label="Matches">${r.matches}</td>
        <td class="center-cell" data-label="Match Wins">${r.wins}</td>
        <td class="center-cell" data-label="Match Losses">${r.losses}</td>
        <td class="center-cell" data-label="Sets Won">${r.setsFor}</td>
        <td class="center-cell" data-label="Sets Lost">${r.setsAgainst}</td>
        <td class="center-cell" data-label="Set Diff">${r.setDiff}</td>
        <td class="center-cell" data-label="Games Won">${r.gamesFor}</td>
        <td class="center-cell" data-label="Games Lost">${r.gamesAgainst}</td>
        <td class="center-cell" data-label="Game Diff">${r.gameDiff}</td>
        <td class="points-cell" data-label="Match Points">${r.points}</td>
      </tr>
    `).join('');
  }

  function renderHistory(){
    if(!matchesLoaded){
      historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">Loading match history from Firebase‚Ä¶</td></tr>';
      return;
    }
    if(matches.length === 0){
      historyBody.innerHTML = '<tr><td colspan="6" class="center-cell" style="color:var(--muted);">No matches recorded.</td></tr>';
      return;
    }
    historyBody.innerHTML = matches.map((m,idx)=>{
      const matchSets = computeMatchSetTotals(m);
      const setsLabel = (matchSets.team1 + matchSets.team2) > 0 ? ` (${matchSets.team1}-${matchSets.team2} sets)` : '';
      const hasLines = Array.isArray(m.lines) && m.lines.length;
      const breakdownParts = [];
      if(hasLines){
        breakdownParts.push(m.lines.map(line=>{
          const sets = formatLineSets(line, { html:true });
          const players = formatLinePlayers(line, m);
          const score = `${Number(line.g1) || 0}-${Number(line.g2) || 0}`;
          return `<div class="history-line"><strong>${escapeHTML(line.label)}:</strong> ${score}${sets}${players}</div>`;
        }).join(''));
      }
      if(m.dreambreaker){
        breakdownParts.push(`<div class="history-line"><strong>Dreambreaker:</strong> ${Number(m.dreambreaker.g1) || 0}-${Number(m.dreambreaker.g2) || 0}</div>`);
      }
      const breakdownCell = breakdownParts.length
        ? ((hasLines || breakdownParts.length > 1)
            ? `<div class="history-breakdown-wrapper" data-breakdown-wrapper>
                <button type="button" class="history-toggle" aria-expanded="false">Show breakdown</button>
                <div class="history-breakdown" hidden>${breakdownParts.join('')}</div>
              </div>`
            : `<div class="history-breakdown open">${breakdownParts.join('')}</div>`)
        : '‚Äî';
      return `
      <tr>
        <td class="rank-cell" data-label="Match #">${matches.length - idx}</td>
        <td class="team-cell" data-label="Teams">${m.t1} vs ${m.t2}</td>
        <td class="center-cell" data-label="Games (Sets)">${m.g1}-${m.g2}${setsLabel}</td>
        <td class="points-cell" data-label="Winner">${m.win}</td>
        <td data-label="Breakdown">${breakdownCell}</td>
        <td class="center-cell" data-label="Date/Time">${new Date(m.ts).toLocaleString()}</td>
      </tr>
    `; }).join('');
  }

  function renderParticipationTables(){
    if(!playerParticipationBody || !pairUsageBody){
      return;
    }
    if(!matchesLoaded){
      playerParticipationBody.innerHTML = '<tr><td colspan="4" class="center-cell" style="color:var(--muted);">Loading participation data‚Ä¶</td></tr>';
      pairUsageBody.innerHTML = '<tr><td colspan="4" class="center-cell" style="color:var(--muted);">Loading pair usage‚Ä¶</td></tr>';
      return;
    }
    const hasLineupData = matches.some(match => Array.isArray(match.lines) && match.lines.some(line => {
      if(!line || !line.players) return false;
      const left = Array.isArray(line.players.team1) ? line.players.team1.filter(Boolean) : [];
      const right = Array.isArray(line.players.team2) ? line.players.team2.filter(Boolean) : [];
      return left.length > 0 || right.length > 0;
    }));
    const { players, pairs } = computeParticipationStats();
    if(players.length === 0){
      const message = matches.length === 0
        ? 'No participation data yet.'
        : (hasLineupData ? 'No participation data yet.' : 'Lineup data is unavailable for the recorded matches.');
      playerParticipationBody.innerHTML = `<tr><td colspan="4" class="center-cell" style="color:var(--muted);">${message}</td></tr>`;
    } else {
      playerParticipationBody.innerHTML = players.map((entry, idx) => `
        <tr class="${entry.days >= 6 ? 'usage-alert' : ''}">
          <td class="rank-cell" data-label="#">${idx + 1}</td>
          <td class="team-cell" data-label="Team">${entry.team}</td>
          <td data-label="Player">${entry.player}</td>
          <td class="center-cell" data-label="Match Days">${entry.days}</td>
        </tr>
      `).join('');
    }
    if(pairs.length === 0){
      const message = matches.length === 0
        ? 'No pair data yet.'
        : (hasLineupData ? 'No pair data yet.' : 'Pairing data is unavailable for the recorded matches.');
      pairUsageBody.innerHTML = `<tr><td colspan="4" class="center-cell" style="color:var(--muted);">${message}</td></tr>`;
    } else {
      pairUsageBody.innerHTML = pairs.map((entry, idx) => `
        <tr class="${entry.days >= 3 ? 'usage-alert' : ''}">
          <td class="rank-cell" data-label="#">${idx + 1}</td>
          <td class="team-cell" data-label="Team">${entry.team}</td>
          <td data-label="Pair">${entry.pair}</td>
          <td class="center-cell" data-label="Match Days">${entry.days}</td>
        </tr>
      `).join('');
    }
  }

  function computeParticipationStats(){
    const playerMap = new Map();
    const pairMap = new Map();
    for(const match of matches){
      const ts = Number(match && match.ts);
      if(!Number.isFinite(ts)) continue;
      const dateKey = new Date(ts).toISOString().split('T')[0];
      if(!dateKey) continue;
      const teams = [
        { key: 'team1', name: match.t1 || 'Team 1' },
        { key: 'team2', name: match.t2 || 'Team 2' }
      ];
      const seenPairsThisMatch = { team1: new Set(), team2: new Set() };
      if(!Array.isArray(match.lines)) continue;
      for(const line of match.lines){
        if(!line || !line.players) continue;
        for(const team of teams){
          const roster = Array.isArray(line.players[team.key]) ? line.players[team.key] : [];
          if(!roster.length) continue;
          roster.filter(Boolean).forEach(player => {
            const name = typeof player === 'string' ? player : String(player);
            const mapKey = `${team.name}|||${name}`;
            if(!playerMap.has(mapKey)){
              playerMap.set(mapKey, { team: team.name, player: name, days: new Set() });
            }
            playerMap.get(mapKey).days.add(dateKey);
          });
          if(line.type === 'singles') continue;
          if(roster.length < 2) continue;
          const normalizedPair = roster.slice(0,2).map(p => typeof p === 'string' ? p : String(p)).filter(Boolean).sort();
          if(normalizedPair.length < 2) continue;
          const pairKey = normalizedPair.join('|||');
          if(seenPairsThisMatch[team.key].has(pairKey)) continue;
          seenPairsThisMatch[team.key].add(pairKey);
          const mapKey = `${team.name}|||${pairKey}`;
          const display = `${normalizedPair[0]} & ${normalizedPair[1]}`;
          if(!pairMap.has(mapKey)){
            pairMap.set(mapKey, { team: team.name, pair: display, days: new Set() });
          }
          pairMap.get(mapKey).days.add(dateKey);
        }
      }
    }
    const players = Array.from(playerMap.values()).map(entry => ({
      team: entry.team,
      player: entry.player,
      days: entry.days.size
    })).sort((a,b) => (b.days - a.days) || a.team.localeCompare(b.team) || a.player.localeCompare(b.player));
    const pairs = Array.from(pairMap.values()).map(entry => ({
      team: entry.team,
      pair: entry.pair,
      days: entry.days.size
    })).sort((a,b) => (b.days - a.days) || a.team.localeCompare(b.team) || a.pair.localeCompare(b.pair));
    return { players, pairs };
  }

  function renderAll(){
    renderStandings();
    renderHistory();
    renderParticipationTables();
  }

  /* ==========
     Actions: Add / Undo / Clear / Import / Export
     ========== */
  document.getElementById('addBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Please wait for existing results to load.');
    const a = t1.value.trim(), b = t2.value.trim();
    if(!a || !b) return alert('Select both teams.');
    if(a === b) return alert('A team cannot play itself.');

    const courts = collectCourtData();
    if(!courts.ok) return alert('‚ö†Ô∏è ' + courts.msg);

    const dream = collectDreambreaker();
    if(!dream.ok) return alert('‚ö†Ô∏è ' + dream.msg);

    const total1 = courts.total1;
    const total2 = courts.total2;
    const sets1 = courts.sets1;
    const sets2 = courts.sets2;

    let win;
    if(total1 > total2){
      win = a;
    } else if(total2 > total1){
      win = b;
    } else {
      if(!dream.dreambreaker) return alert('‚ö†Ô∏è Totals are tied. Enter the dreambreaker result.');
      win = dream.dreambreaker.g1 > dream.dreambreaker.g2 ? a : b;
    }

    const record = {
      t1:a,
      t2:b,
      g1: total1,
      g2: total2,
      s1: sets1,
      s2: sets2,
      win,
      ts: Date.now(),
      lines: courts.lines
    };
    record.sets = { team1: sets1, team2: sets2 };
    if(dream.dreambreaker) record.dreambreaker = dream.dreambreaker;

    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.push(record);

      // Clear inputs after successful save
      t1.value = '';
      t2.value = '';
      clearLineScores();
      refreshAllLineTeamLabels();
      dreambreakerToggle.checked = false;
      dreambreakerFields.classList.add('hidden');
      dreambreakerTeam1.value = '';
      dreambreakerTeam2.value = '';

      const setNote = (sets1 + sets2) > 0 ? `\nSets: ${sets1}-${sets2}` : '';
      const dreamNote = record.dreambreaker ? `\nDreambreaker: ${record.dreambreaker.g1}-${record.dreambreaker.g2}` : '';
      alert(`‚úÖ Saved: ${a} ${record.g1}-${record.g2} ${b}\nWinner: ${win} (+1 match point)${setNote}${dreamNote}`);
    } catch(err){
      console.error('Failed to save match', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('‚ùå Failed to save match. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('undoBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    if(matches.length === 0) return alert('Nothing to undo.');
    const last = matches[0];
    const matchSets = computeMatchSetTotals(last);
    const setsLine = (matchSets.team1 + matchSets.team2) > 0 ? `\nSets: ${matchSets.team1}-${matchSets.team2}` : '';
    const courts = Array.isArray(last.lines) && last.lines.length ? '\nCourts: ' + last.lines.map(l=>{
      const sets = formatLineSets(l);
      const players = formatLinePlayersText(l, last);
      const playersNote = players ? ` [${players}]` : '';
      return `${l.label} ${l.g1}-${l.g2}${sets}${playersNote}`;
    }).join('; ') : '';
    const dream = last.dreambreaker ? `\nDreambreaker ${last.dreambreaker.g1}-${last.dreambreaker.g2}` : '';
    if(!confirm(`Undo last match?\n${last.t1} ${last.g1}-${last.g2} ${last.t2}${setsLine}${courts}${dream}`)) return;
    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.child(last.id).remove();
    } catch(err){
      console.error('Failed to undo match', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('‚ùå Failed to undo match. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('clearBtn').addEventListener('click', async () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    if(matches.length === 0) return alert('Nothing to clear.');
    if(!confirm('Clear ALL match results?')) return;
    if(!(await guardWriteAccess())) return;

    try {
      await matchesRef.remove();
    } catch(err){
      console.error('Failed to clear matches', err);
      if(err && err.code === 'PERMISSION_DENIED'){
        authReady = false;
        authError = err;
      }
      alert('‚ùå Failed to clear matches. ' + (err && err.message ? err.message : 'Please try again.'));
    }
  });

  document.getElementById('exportBtn').addEventListener('click', () => {
    if(!matchesLoaded) return alert('Results are still loading.');
    const payload = matches.map(({id, ...rest}) => rest);
    const blob = new Blob([JSON.stringify(payload,null,2)], { type:'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'koc-season2-matches.json';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  document.getElementById('importFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async () => {
      try{
        const data = JSON.parse(reader.result);
        if(!Array.isArray(data)) throw new Error('Invalid JSON shape');
        // quick sanity check
        const upgraded = data.map(entry => {
          const u = upgradeMatch(entry);
          if(!u) throw new Error('Malformed match entry (invalid games)');
          if(!TEAMS.includes(u.t1) || !TEAMS.includes(u.t2)) throw new Error('Unknown team in data');
          if(u.win !== u.t1 && u.win !== u.t2) throw new Error('Match is missing a winner');
          const { id, ...clean } = u;
          return clean;
        });
        if(!(await guardWriteAccess())) return;

        if(upgraded.length === 0){
          await matchesRef.set(null);
        } else {
          const updates = {};
          upgraded.forEach(entry => {
            const key = matchesRef.push().key;
            updates[key] = entry;
          });
          await matchesRef.set(updates);
        }
        alert('‚úÖ Import successful.');
      } catch(err){
        console.error(err);
        if(err && err.code === 'PERMISSION_DENIED'){
          authReady = false;
          authError = err;
        }
        alert('‚ùå Import failed: ' + err.message);
      } finally {
        e.target.value = '';
      }
    };
    reader.onerror = () => {
      alert('‚ùå Failed to read file.');
      e.target.value = '';
    };
    reader.readAsText(file);
  });

  /* ==========
     Initial render
     ========== */
  renderAll();
</script>
</body>
</html>
